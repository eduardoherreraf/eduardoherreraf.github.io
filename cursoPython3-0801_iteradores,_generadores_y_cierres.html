<!DOCTYPE html><html lang="es" data-bs-theme="dark"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Domina iteradores, generadores y cierres en Python: técnicas avanzadas para código eficiente, optimizado y con manejo inteligente de recursos."><meta name="tittle" content="Iteradores, Generadores y Cierres Python 3 - Ing. Eduardo Herrera Forero."><meta name="author" content="Ing. Eduardo Herrera Forero"><meta name="application-name" content="EHF"><meta name="robots" content="index, follow"><link rel="canonical" href="https://eduardoherreraf.github.io/cursoPython3-0801_iteradores,_generadores_y_cierres.html"><meta property="og:type" content="website"><meta property="og:title" content="Iteradores, Generadores y Cierres Python 3 - Ing. Eduardo Herrera Forero."><meta property="og:description" content="Domina iteradores, generadores y cierres en Python: técnicas avanzadas para código eficiente, optimizado y con manejo inteligente de recursos."><meta property="og:image" content="https://i.imgur.com/JKbKYrO.png"><meta property="og:image:alt" content="Logo del ingeniero Eduardo Herrera Forero"><meta property="og:url" content="https://eduardoherreraf.github.io/cursoPython3-0801_iteradores,_generadores_y_cierres.html"><meta property="og:locale" content="es_CO"><meta name="twitter:card" content="content" ="summary"><meta name="twitter:title" content="Iteradores, Generadores y Cierres Python 3 - Ing. Eduardo Herrera Forero."><meta name="twitter:description" content="Domina iteradores, generadores y cierres en Python: técnicas avanzadas para código eficiente, optimizado y con manejo inteligente de recursos."><meta name="twitter:image" content="https://i.imgur.com/JKbKYrO.png"><meta name="twitter:image:alt" content="Logo del ingeniero Eduardo Herrera Forero"><meta name="twitter:url" content="https://eduardoherreraf.github.io/cursoPython3-0801_iteradores,_generadores_y_cierres.html"><meta name="twitter:site" content="@ehfeduardo"><link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.d2cbc014.png"><link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.02c0440e.png"><link rel="icon" type="image/png" sizes="192x192" href="android-chrome-192x192.9d63268f.png"><link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.a17b4569.png"><link rel="manifest" href="site.webmanifest"><link rel="mask-icon" href="safari-pinned-tab.cd218f89.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><title>Iteradores, Generadores y Cierres Python 3 - Ing. Eduardo Herrera Forero.</title><link rel="stylesheet" href="index.bafe30a1.css"><script type="module" defer src="index.d07dbcde.js"></script><meta name="google-site-verification" content="2H5ZMCD1_xl7oxaiqnopfdQBnIXVIOfmW0UBSa5sQJc"></head><body>  <nav class="border border-1 fixed-top nav-underline navbar navbar-expand-lg"> <div class="container-fluid">  <a class="align-items-center d-flex ms-2 navbar-brand text-decoration-none" href="index.html"> <img src="logo.f31ffce0.png" alt="Logo de Ing. Eduardo Herrera Forero" width="30" height="30" class="align-text-top d-inline-block me-1"> <span class="d-lg-inline d-none">Ing. Eduardo Herrera Forero</span> </a>  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button>  <div class="collapse ms-auto navbar-collapse text-center" id="navbarSupportedContent"> <ul class="justify-content-lg-end mb-2 mb-lg-0 ms-auto navbar-nav w-100"> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html">SOBRE MÍ</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#resume">EXPERIENCIA</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#portfolio">PORTAFOLIO</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#studies">ESTUDIOS</a> </li> <li class="nav-item"> <a class="active mx-1 nav-link text-decoration-none" href="index.html#blog">PUBLICACIONES</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#contact">CONTACTO</a> </li> </ul> </div> </div> </nav>   <div class="col mx-1 row"> <main class="col-lg-9 pt-5"> <section class="pb-3">  <article class="border-1 border-bottom pb-3 row" data-bs-spy="scroll" data-bs-target="#list-example" data-bs-smooth-scroll="true"> <div> <header> <h1>Iteradores, Generadores y Cierres en Python</h1> </header> <p> En este documento se explorarán los conceptos de iteradores, generadores y cierres en Python, tres características fundamentales que permiten manejar la iteración y el manejo de funciones de manera eficiente. A través de ejemplos y explicaciones claras, se busca proporcionar una comprensión profunda de cómo funcionan estos elementos y cómo pueden ser utilizados para mejorar la calidad y la eficiencia del código en Python. </p> <div class="imagen text-center"> <picture> <img src="https://i.ibb.co/h2ddmyG/iteradoresgeneradorescierres.jpg" class="img-fluid rounded-4" width="50%" alt="Iteradores, Generadores y Cierres en Python  " title="Dominando los conceptos clave de Python"> <figcaption>Iteradores, Generadores y Cierres en Python</figcaption> </picture> </div>  <div id="iteradores" class="mt-5"> <h2 class="mt-1">Iteradores</h2> <p> Un iterador en Python es un objeto que permite recorrer una colección de elementos uno por uno sin necesidad de cargar todos los elementos a la vez. Para entenderlo, se puede comparar con un reproductor de música que tiene una lista de canciones. El reproductor sabe cuál es la canción actual y tiene un botón de "siguiente" para pasar a la siguiente canción. Cuando no hay más canciones, el reproductor informa que se llegó al final de la lista. </p> <p> En programación, un iterador hace algo similar. Tiene una "lista" de cosas (que puede ser números, palabras, etc.) y las entrega una por una cuando se le pide. </p> <p><strong>Características principales</strong>:</p> <ul> <li> Es un objeto que implementa los métodos <code>__iter__()</code> y <code>__next__()</code>. </li> <li> Permite procesar elementos uno a uno, lo que es útil para trabajar con grandes conjuntos de datos. </li> <li> Cuando no hay más elementos, lanza una excepción <code>StopIteration</code>. </li> </ul>  <div> <h3>__iter__()</h3>  <div> <h4>¿Qué Es __iter__()?</h4> <ul> <li> <code>__iter__()</code> es un método especial en Python que convierte un objeto en iterable. </li> <li> Un objeto iterable es aquel que puede ser recorrido (iterado) elemento por elemento, como en un bucle <code>for</code>. </li> <li> Este método es una de las piezas fundamentales del protocolo de iteración en Python. </li> </ul> </div>   <div> <h4>¿Qué Hace __iter__()?</h4> <ul> <li> Devuelve un iterador (es decir, un objeto que implementa el método <code>__next__()</code>). </li> <li> Cuando llamamos a iter(objeto), en realidad se ejecuta el método objeto.<code>__iter__()</code>. </li> <li> Si el objeto es ya un iterador, <code>__iter__()</code> debe devolver el mismo objeto. </li> </ul> </div>   <div> <h4>Relación Entre <code>__iter__()</code> y __next__()</h4> <ul> <li><code>__iter__()</code> crea un iterador o devuelve uno existente.</li> <li> El método <code>__next__()</code> del iterador devuelve los elementos uno por uno y lanza una excepción <code>StopIteration</code> cuando no hay más elementos para iterar. </li> </ul> </div>  </div>   <div> <h3>__next__()</h3>  <div> <h4>¿Qué Es __next__() en Python?</h4> <p> El método <code> __next__()</code> es una función especial en Python que se utiliza para obtener el siguiente elemento de un iterador. Forma parte del protocolo de iteradores en Python, junto con el método <code>__iter__()</code>. </p> <p> Cuando se llama a <code>__next__()</code>, el iterador avanza al siguiente elemento. Si ya no hay más elementos, lanza una excepción <code>StopIteration</code> para indicar que la iteración ha terminado. </p> </div>   <div> <h4>¿Qué Hace __next__()?</h4> <ul> <li> <strong>Obtiene el siguiente elemento del iterador</strong>: Cada vez que se llama a <code>__next__()</code>, el iterador entrega el siguiente valor disponible. </li> <li> <strong>Mantiene el estado interno del iterador</strong>: El iterador "recuerda" dónde se quedó para que pueda continuar desde el punto donde fue pausado. </li> <li> <strong>Lanza una excepción cuando no hay más elementos</strong>: Si el iterador no tiene más elementos, se lanza una excepción <code>StopIteration</code>, que se utiliza para detener bucles como for. </li> </ul> </div>  </div>   <div> <h3>Ejemplo de Uso Iteradores</h3> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    mi_lista = [1, 2, 3]
                    mi_iterador = iter(mi_lista)  # Convierte la lista en un iterador
                    print(next(mi_iterador))  # Salida:: 1
                    print(next(mi_iterador))  # Salida:: 2
                    print(next(mi_iterador))  # Salida:: 3
                    print(next(mi_iterador))
                    """
                    Muestra:
                    Traceback (most recent call last):
                      File "&lt;archivo>", line &lt;número de línea>, in &lt;módulo>
                        print(next(mi_iterador))
                          StopIteration
                    """
                  </code>
                </pre> <p><strong>Explicación del código</strong>:</p> <ul> <li>Se crea una lista <code>mi_lista</code>: <code>[1, 2, 3]</code>.</li> <li><code>iter(mi_lista)</code> convierte la lista en un iterador.</li> <li> Se usa <code>next(mi_iterador)</code> para pedir el siguiente elemento: La primera vez devuelve <code>1</code>, luego <code>2</code> y finalmente <code>3</code>. </li> <li> Cuando no hay más elementos, se lanza un error <code>StopIteration</code>. </li> </ul> </div>  </div>   <div id="generadores" class="mt-5"> <h2 class="mt-1">Generadores</h2> <p> Un generador es como una máquina de café que hace un café solo cuando se le pide, en lugar de preparar todos los cafés de antemano. </p> <p> Imaginar que se tiene una cafetería y no se sabe cuántos clientes van a llegar. En lugar de hacer 100 cafés por adelantado, se prepara un café solo cuando alguien lo pide. Así, se ahorra recursos (café, leche, etc.) y tiempo. </p> <p> En programación, un generador funciona así: se crea los valores uno por uno cuando se necesite, en lugar de generar todos de una vez. </p>  <div> <h3>yield</h3> <p> En Python, <code>yield</code> es una palabra clave que se utiliza dentro de funciones para crear generadores. Un generador es una función que permite devolver un valor, pausando su estado actual, y retomarlo desde el mismo punto en una próxima iteración. Esto hace que las funciones con <code>yield</code> se comporten de manera diferente a las funciones tradicionales que usan <code>return</code>. </p>  <div> <h4>¿Cómo Funciona yield?</h4> <ul> <li> Cuando una función contiene al menos una instrucción <code>yield</code>, se convierte en un generador. </li> <li> En lugar de ejecutar completamente la función y devolver un valor, <code>yield</code> devuelve un valor parcial y "pausa" la ejecución. </li> <li> Cuando se vuelve a llamar al generador (por ejemplo, con un bucle o el método <code>next()</code>), la ejecución se reanuda justo después de la instrucción <code>yield</code> previa. </li> </ul> </div>   <div> <h4>¿Qué Hace yield?</h4> <p> <code>yield</code> permite generar elementos uno a uno según se necesiten, en lugar de calcularlos todos de una vez. Esto lo hace ideal para: </p> <ul> <li> <span class="fw-bold">Ahorrar memoria</span>: Los generadores no almacenan todos los valores en memoria como lo haría una lista. </li> <li> <span class="fw-bold">Procesar datos en secuencia</span>: Útil para manejar flujos de datos grandes o infinitos. </li> </ul> </div>   <div> <h4>Diferencias Clave entre yield y return</h4> <table class="table table-bordered table-dark text-center"> <thead> <tr> <th scope="col">Característica</th> <th scope="col"><code>yield</code></th> <th scope="col"><code>return</code></th> </tr> </thead> <tbody> <tr> <td>Pausa la ejecución</td> <td>Sí</td> <td>No</td> </tr> <tr> <td>Permite múltiples valores</td> <td>Sí (a través de iteraciones)</td> <td>No</td> </tr> <tr> <td>Convierte la función en</td> <td>Generador</td> <td>Función normal</td> </tr> </tbody> </table> </div>   <div> <h4>Ejemplo de Código Generador Usando yield</h4> <p> A continuación se presenta un ejemplo sencillo de un generador en Python. El código genera números del 1 al 5, uno a la vez, en lugar de crear toda la lista en memoria. </p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                    <code class="language-python" data-prismjs-copy="Copy">
                      def generador_numeros():
                          for numero in range(1, 6):
                              yield numero
                      # Uso del generador
                      for valor in generador_numeros():
                          print(valor)
                      # Salida:: 1
                      # Salida:: 2
                      # Salida:: 3
                      # Salida:: 4
                      # Salida:: 5
                    </code>
                  </pre> <p><strong>Explicación</strong>:</p> <ul> <li> Cuando se llama a <code>generador_numeros()</code>, no ejecuta el código de inmediato. En cambio, devuelve un objeto generador. </li> <li> Al iterar sobre ese objeto (por ejemplo, con un bucle <code>for</code>), la función empieza a ejecutarse hasta encontrar un <code>yield</code>. </li> <li> Cada vez que se llega a <code>yield</code>, se devuelve el valor y la ejecución de la función se pausa hasta la próxima iteración. </li> </ul> </div>  </div>   <div> <h3>Listas de Compresión</h3> <p> Los generadores por comprensión (también conocidos como generator expressions en Python) son una forma eficiente de crear iteradores utilizando una sintaxis similar a las listas por comprensión, pero en lugar de generar una lista completa en memoria, producen los elementos uno a uno según se necesiten. Esto ahorra memoria y es especialmente útil para manejar grandes conjuntos de datos. </p>  <div> <h4>Sintaxis Básica de Listas por Comprensión</h4> <p> La sintaxis de un generador por comprensión es similar a una lista por comprensión, pero utiliza paréntesis <code>()</code> en lugar de corchetes <code>[]</code>. </p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                    <code class="language-python" data-prismjs-copy="Copy">
                      generador = (expresión for elemento in iterable if condición)
                    </code>
                  </pre> <ul> <li> <span class="fw-bold"><code>expresión</code></span>: el valor que será generado por el generador. </li> <li> <span class="fw-bold"><code>elemento</code></span>: la variable que toma cada valor del iterable. </li> <li> <span class="fw-bold"><code>iterable</code></span>: la fuente de datos que se recorre. </li> <li> <span class="fw-bold"><code>condición</code></span>: (opcional) filtra los valores del iterable que cumplen con esta condición. </li> </ul> </div>   <div> <h4>Ejemplo de Código Generador Usando Listas por Comprensión</h4> <p>Generar cuadrados de los números del 1 al 5:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                    <code class="language-python" data-prismjs-copy="Copy">
                      generador = (x**2 for x in range(1, 6))
                      print(generador)  # Salida: que es un objeto generador
                      for valor in generador:
                          print(valor)  # Imprime los cuadrados: 1, 4, 9, 16, 25
                    </code>
                  </pre> </div>   <div> <h4>Usando Operador in en Generadores</h4> <p> En Python, el operador <code>in</code> se utiliza para verificar si un elemento está presente en una secuencia, como una lista, tupla, cadena o conjunto. Aunque no es un "generador" en sí mismo, puede ser empleado dentro de comprensiones o expresiones generadoras para filtrar elementos que cumplen con ciertas condiciones. </p> <p> A continuación se presenta un ejemplo de cómo usar <code>in</code> en el contexto de una expresión generadora: </p> <p> <strong>Ejemplo de <code>in</code> con una expresión generadora</strong>: </p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                    <code class="language-python" data-prismjs-copy="Copy">
                      # Lista de palabras
                      palabras = ["manzana", "banana", "naranja", "uva"]
                      # Generador para palabras que contienen la letra 'a'
                      generador = (palabra for palabra in palabras if 'a' in palabra)
                      # Iterar sobre el generador
                      for palabra in generador:
                          print(palabra)
                      # Salida:: manzana
                      # Salida:: banana
                      # Salida:: naranja
                      # Salida:: uva
                    </code>
                  </pre> <p><strong>Explicación</strong>:</p> <ul> <li> <code>palabra for palabra in palabras if 'a' in palabra</code>: <ul> <li>Esto es una expresión generadora.</li> <li> Itera sobre cada palabra en la lista <code>palabras</code>. </li> <li> Filtra solo aquellas palabras que contienen la letra <code>'a'</code> usando el operador <code>in</code>. </li> </ul> </li> <li> El generador devuelve los elementos uno a uno bajo demanda, lo que ahorra memoria en comparación con una lista. </li> </ul> </div>   <div> <h4>Diferencias clave con Listas por Comprensión</h4> <table class="align-middle table table-bordered table-dark text-center"> <thead> <tr> <th>Característica</th> <th>Lista por comprensión</th> <th>Generador por comprensión</th> </tr> </thead> <tbody> <tr> <th scope="row" class="text-start"> Sintaxis </th> <td><code>[expresión for ... in ...]</code></td> <td><code>(expresión for ... in ...)</code></td> </tr> <tr> <th scope="row" class="text-start"> Memoria </th> <td>Carga todos los elementos en memoria</td> <td>Genera elementos bajo demanda</td> </tr> <tr> <th scope="row" class="text-start"> Iterabilidad </th> <td>Es una lista (puede ser iterada varias veces)</td> <td>Es un iterador (se consume al iterar)</td> </tr> </tbody> </table> </div>  </div>   <div> <h3>Ventajas de los Generadores</h3> <p> Los generadores ofrecen varias ventajas, especialmente en contextos donde se necesita generar elementos de manera eficiente y flexible. A continuación, se mencionan algunas de las principales ventajas de utilizar generadores: </p> <ul> <li> <span class="fw-bold">Uso eficiente de memoria</span>: Los generadores son iteradores que producen elementos bajo demanda, lo que significa que no almacenan todos los elementos en memoria al mismo tiempo. Esto permite trabajar con grandes volúmenes de datos sin consumir demasiada memoria, lo que es especialmente útil cuando se manejan archivos grandes o secuencias de datos interminables. </li> <li> <span class="fw-bold">Mayor rendimiento</span>: Al generar los elementos de forma perezosa (es decir, solo cuando son necesarios), los generadores pueden ser más rápidos en comparación con las listas u otras estructuras que deben generar todos los elementos de antemano. </li> <li> <span class="fw-bold">Simplicidad en el código</span>: Los generadores permiten escribir código más limpio y conciso, especialmente en situaciones donde se necesita trabajar con secuencias de datos que deben ser procesadas de manera incremental. Su sintaxis es simple, utilizando la palabra clave yield en lugar de tener que gestionar explícitamente la creación y el mantenimiento de una lista. </li> <li> <span class="fw-bold">Facilitan la composición de funciones</span>: Los generadores permiten encadenar varias operaciones de manera sencilla. Esto es útil cuando se necesita realizar una secuencia de transformaciones sobre los datos, sin necesidad de almacenar intermedios innecesarios. </li> <li> <span class="fw-bold">Control de flujo más flexible</span>: El uso de yield permite pausar y reanudar la ejecución de una función, lo que es útil en escenarios como la implementación de algoritmos de búsqueda, recorridos, o cuando se necesita manejar flujos de trabajo asíncronos. </li> </ul> </div>  </div>   <div id="cierres" class="mt-5"> <h2 class="mt-1">Cierres</h2> <p> En Python, el término "cierres" o "closures" se refiere a una función interna que tiene acceso a las variables de su función externa, incluso después de que la función externa haya finalizado su ejecución. Es una forma de encapsular el estado y la funcionalidad, y se utiliza principalmente para crear funciones que recuerdan el entorno en el que fueron creadas. </p>  <div> <h3>¿Cómo Funcionan los Cierres?</h3> <p>Un cierre ocurre cuando:</p> <ul> <li>Una función interna accede a las variables de su función externa.</li> <li> La función interna se devuelve o se utiliza fuera de su contexto original, pero mantiene acceso a esas variables externas. </li> </ul> <p><strong>Ejemplo básico de cierre</strong>:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    def <code>funcion_externa</code>(x):
                        def <code>funcion_interna</code>(y):
                        return x + y
                    return <code>funcion_interna</code>
                    # Crear una nueva función con x = 10
                    mi_funcion = <code>funcion_externa</code>(10)
                    # Llamar a la función interna con y = 5
                    resultado = mi_funcion(5)  # Devuelve 15
                    print(resultado)
                  </code>
                </pre> <p>En este ejemplo:</p> <ul> <li> <code><code>funcion_externa</code></code> toma un argumento <code>x</code> y define una función interna <code>funcion_interna</code>. </li> <li> <code>funcion_interna</code> tiene acceso a <code>x</code> de <code>funcion_externa</code> a través de un cierre. </li> <li> Aunque la ejecución de <code>funcion_externa</code> ya ha terminado, <code>funcion_interna</code> aún puede acceder a la variable <code>x</code>. </li> </ul> </div>   <div> <h3>Uso Típico de Cierres</h3> <p> Los cierres son útiles cuando se necesita preservar un estado dentro de una función, y se suelen utilizar en escenarios como la creación de contadores, funciones de configuración, o funciones que manejan callbacks. </p> <p> <strong>Ejemplo práctico de cierre para un contador</strong> </p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    def contador():
                    contador = 0
                    def incrementar():
                        nonlocal contador  # Se refiere a la variable externa
                        contador += 1
                        return contador
                    return incrementar
                    # Crear un contador
                    mi_contador = contador()
                    # Llamar varias veces al contador
                    print(mi_contador())  # Devuelve 1
                    print(mi_contador())  # Devuelve 2
                    print(mi_contador())  # Devuelve 3
                  </code>
                </pre> <p> En este ejemplo, <code>mi_contador</code> es una función que recuerda y actualiza el valor de contador cada vez que se llama. El uso de <code>nonlocal</code> permite que la variable contador se modifique en el ámbito de la función externa. </p> </div>   <div> <h3>Ventajas de los Cierres</h3> <ul> <li> <span class="fw-bold">Encapsulamiento</span>: Permiten ocultar detalles internos, ya que el estado se mantiene dentro de la función interna. </li> <li> <span class="fw-bold">Funcionalidad avanzada</span>: Facilitan patrones como la creación de funciones personalizadas o la configuración de comportamientos en funciones de alto orden. </li> </ul> </div>  </div>   <div id="laFuncionLambda" class="mt-5"> <h2 class="mt-1">La Función lambda</h2> <p> Una función <code>lambda</code> en Python es una forma de definir funciones anónimas o funciones pequeñas y de una sola línea sin necesidad de usar la palabra clave def ni asignarles un nombre explícito. Estas funciones son útiles para operaciones rápidas y simples, especialmente cuando no es necesario reutilizarlas. </p>  <div> <h3>Qué Es una Función lambda</h3> <p>Una función <code>lambda</code> es una expresión que:</p> <ul> <li>Se define con la palabra clave <code>lambda</code>.</li> <li>No necesita un nombre explícito.</li> <li>Puede tener múltiples argumentos, pero solo una expresión (una línea de código).</li> <li> Devuelve el resultado de la expresión automáticamente, sin necesidad de usar <code>return</code>. </li> </ul> <p><strong>Sintaxis básica</strong>:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    lambda argumentos: expresión
                  </code>
                </pre> </div>   <div> <h3>Cómo se Usa una Función lambda</h3> <ul> <li> <span class="fw-bold">Como funciones anónimas</span>: Se usan directamente sin necesidad de asignarlas a un nombre. Por ejemplo: <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                      <code class="language-python" data-prismjs-copy="Copy">
                        resultado = (lambda x, y: x + y)(5, 3)
                        print(resultado)  # Salida: 8
                      </code>
                    </pre> </li> <li> <span class="fw-bold">Asignadas a variables</span>: Se puede asignar a una variable para usarlas como funciones normales. <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                      <code class="language-python" data-prismjs-copy="Copy">
                        sumar = lambda x, y: x + y
                        print(sumar(10, 20))  # Salida: 30
                      </code>
                    </pre> </li> <li> <span class="fw-bold">En funciones como argumento</span>: Son útiles en funciones como <code>map</code>, <code>filter</code> y <code>sorted</code> que aceptan otras funciones como parámetros. <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                      <code class="language-python" data-prismjs-copy="Copy">
                        numeros = [1, 2, 3, 4]
                        cuadrados = list(map(lambda x: x ** 2, numeros))
                        print(cuadrados)  # Salida: [1, 4, 9, 16]
                      </code>
                    </pre> </li> <li> <span class="fw-bold">En listas o diccionarios</span>: Pueden ser usadas para transformar o filtrar elementos dinámicamente. <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                      <code class="language-python" data-prismjs-copy="Copy">
                        palabras = ["python", "lambda", "función"]
                        longitudes = list(map(lambda palabra: len(palabra), palabras))
                        print(longitudes)  # Salida: [6, 6, 7]
                      </code>
                    </pre> </li> </ul> </div>   <div> <h3>Para qué Sirve una Función lambda</h3> <ul> <li> Optimizar código corto: Se usan para operaciones rápidas donde definir una función tradicional puede ser innecesario. </li> <li> Trabajar con funciones de orden superior: Ideal para map, filter, reduce y otras funciones que necesitan funciones como argumentos. </li> <li> Definir funciones temporales: Permite realizar transformaciones, filtros o cálculos simples sin sobrecargar el código con funciones extra. </li> </ul> </div>   <div> <h3>Ejemplo Práctico de Funciones lambda</h3> <p>Ordenar una lista de tuplas por el segundo elemento:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    datos = [(1, 'b'), (3, 'a'), (2, 'c')]
                    datos_ordenados = sorted(datos, key=lambda x: x[1])
                    print(datos_ordenados)  # Salida: [(3, 'a'), (1, 'b'), (2, 'c')]
                  </code>
                </pre> </div>   <div> <h3>Ventajas de Funciones lambdas</h3> <ul> <li> <span class="fw-bold">Sintaxis concisa</span>: Las funciones lambda permiten definir funciones de una sola línea sin necesidad de un bloque <code>def</code>. Esto reduce la cantidad de código, haciéndolo más legible en tareas simples. <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                      <code class="language-python" data-prismjs-copy="Copy">
                        suma = lambda x, y: x + y
                        print(suma(3, 4))  # Salida: 7
                      </code>
                    </pre> </li> <li> <span class="fw-bold">Uso inmediato (funciones anónimas)</span>: <ul> <li> Las funciones lambda no requieren un nombre explícito, lo que las hace ideales para usos temporales. </li> <li> Ejemplo: En un <code>map</code>, <code>filter</code> o <code>reduce</code>: <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                          <code class="language-python" data-prismjs-copy="Copy">
                            lista = [1, 2, 3, 4]
                            cuadrados = map(lambda x: x**2, lista)
                            print(list(cuadrados))  # Salida: [1, 4, 9, 16]
                          </code>
                        </pre> </li> </ul> </li> <li> <span class="fw-bold">Mejor integración con otras funciones</span>: Son prácticas para usar en expresiones de orden superior como <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, o incluso en funciones personalizadas que aceptan otras funciones como argumentos. </li> <li> <span class="fw-bold">Código más legible en casos simples</span>: <ul> <li> Cuando las operaciones son breves, las funciones lambda evitan la necesidad de declarar una función completa, simplificando el código. </li> <li> Ejemplo: Ordenar una lista de tuplas por el segundo valor. <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                        <code class="language-python" data-prismjs-copy="Copy">
                          datos = [(1, 'a'), (3, 'c'), (2, 'b')]
                          datos_ordenados = sorted(datos, key=lambda x: x[1])
                          print(datos_ordenados)  # Salida: [(1, 'a'), (2, 'b'), (3, 'c')]
                        </code>
                      </pre> </li> </ul> </li> <li> <span class="fw-bold">Flexibilidad en programación funcional</span>: Facilitan la programación funcional al permitir crear funciones inline que pueden pasar como argumentos a otras funciones. </li> <li> <span class="fw-bold">Eficiencia en uso temporal</span>: Cuando se necesita una función pequeña que se usará una sola vez, las funciones lambda evitan la sobrecarga de crear funciones con nombre. </li> </ul> </div>   <div> <h3>Limitaciones de Funciones lambdas</h3> <ul> <li> <span class="fw-bold">Una sola expresión</span>: <ul> <li> Las funciones lambda solo pueden contener una única expresión, la cual se evalúa y devuelve automáticamente. No pueden incluir múltiples líneas, declaraciones o bloques complejos. </li> <li> Ejemplo válido: <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                          <code class="language-python" data-prismjs-copy="Copy">
                            suma = lambda x, y: x + y
                            print(suma(2, 3))  # Salida: 5
                          </code>
                        </pre> </li> <li> Ejemplo inválido: <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                          <code class="language-python" data-prismjs-copy="Copy">
                            # Esto generará un error porque lambda no permite múltiples líneas
                            operacion = lambda x: (
                                x + 1,
                                x - 1
                            )
                          </code>
                        </pre> </li> </ul> </li> <li> <span class="fw-bold">Sin declaraciones</span>: <ul> <li> No pueden contener declaraciones como if, for, while, try, etc. Solo aceptan una expresión, aunque puedes usar operadores ternarios o comprensiones. </li> <li> Ejemplo válido con operador ternario: <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                          <code class="language-python" data-prismjs-copy="Copy">
                            par_o_impar = lambda x: "par" if x % 2 == 0 else "impar"
                            print(par_o_impar(4))  # Salida: "par"
                          </code>
                        </pre> </li> <li> Ejemplo inválido: <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                          <code class="language-python" data-prismjs-copy="Copy">
                            # Esto generará un error porque "for" no es permitido en una lambda
                            sumar_lista = lambda lista: for x in lista: x + 1
                          </code>
                        </pre> </li> </ul> </li> <li> <span class="fw-bold">Sin nombre explícito</span>:Aunque puedes asignar una función lambda a una variable, no tiene un nombre interno como las funciones definidas con <code>def</code>. Esto significa que puede ser menos útil para depuración o documentación. <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                      <code class="language-python" data-prismjs-copy="Copy">
                        multiplicar = lambda x, y: x * y
                        print(multiplicar(2, 3))  # Salida: 6
                      </code>
                    </pre> </li> <li> <span class="fw-bold">Sin anotaciones de tipo</span>: <ul> <li> No puedes agregar anotaciones de tipo a una función lambda, a diferencia de las funciones definidas con <code>def</code>. </li> <li> Ejemplo válido con <code>def</code>: <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                          <code class="language-python" data-prismjs-copy="Copy">
                            def sumar(x: int, y: int) -> int:
                            return x + y
                          </code>
                        </pre> </li> <li>Esto no es posible con una función lambda.</li> </ul> </li> <li> <span class="fw-bold">Complejidad limitada</span>: <ul> <li> No están diseñadas para lógica compleja o reutilización extensiva. Son más útiles para funciones pequeñas que serán utilizadas de manera inmediata, como en expresiones de orden superior (por ejemplo, <code>map</code>, <code>filter</code>, <code>reduce</code>). </li> <li> Ejemplo con map: <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                          <code class="language-python" data-prismjs-copy="Copy">
                            numeros = [1, 2, 3, 4]
                            cuadrados = map(lambda x: x**2, numeros)
                            print(list(cuadrados))  # Salida: [1, 4, 9, 16]
                          </code>
                        </pre> </li> </ul> </li> <li> <span class="fw-bold">Sin soporte para return explícito</span>: No puedes usar la palabra clave return dentro de una lambda, ya que siempre devuelve implícitamente el resultado de la expresión. <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                      <code class="language-python" data-prismjs-copy="Copy">
                        # Correcto
                        suma = lambda x, y: x + y
                      </code>
                    </pre> </li> </ul> </div>  </div>  <div class="mt-5"> <h3 class="mt-1">Funciones lambda con map()</h3> <p> En Python, <code>lambda</code> y <code>map()</code> son herramientas poderosas que se utilizan para trabajar con funciones de manera más concisa y eficiente. </p> <p> La función <code>map()</code> aplica una función a cada elemento de un iterable (como una lista) y devuelve un iterable de los resultados. </p> <p><strong>Sintaxis</strong>:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                <code class="language-python" data-prismjs-copy="Copy">
                  map(func, iterable)
                </code>
              </pre> <ul> <li> <span class="fw-bold"><code>func</code></span>: una función que se aplica a cada elemento del iterable. </li> <li> <span class="fw-bold"><code>iterable</code></span>: una lista, tupla u otro iterable. </li> </ul> <p> Cuando se usa <code>lambda</code> con <code>map()</code>, se puede pasar una función anónima para realizar la operación. </p> <p><strong>Ejemplo</strong>:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                <code class="language-python" data-prismjs-copy="Copy">
                  # Multiplicar cada número de la lista por 2 usando lambda y map
                  numbers = [1, 2, 3, 4, 5]
                  result = map(lambda x: x * 2, numbers)
                  print(list(result))  # [2, 4, 6, 8, 10]
                  </code>
              </pre> <p> En este ejemplo, <code>lambda x: x * 2</code> es la función que multiplica cada número por <code>2</code>. </p> </div>   <div class="mt-5"> <h3 class="mt-1">Funciones lambda con filter()</h3> <p> La función <code>filter()</code> se utiliza para filtrar los elementos de un iterable basándose en una condición. Devuelve un iterable con solo los elementos que cumplen con la condición. </p> <p><strong>Sintaxis</strong>:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                <code class="language-python" data-prismjs-copy="Copy">
                  filter(func, iterable)
                </code>
              </pre> <ul> <li> <code>func</code>: una función que devuelve <code>True</code> o<code> False</code> para cada elemento. </li> <li><code>iterable</code>: una lista, tupla u otro iterable.</li> </ul> <p> Cuando se usa <code>lambda</code> con <code>filter()</code>, se define una condición anónima para filtrar los elementos. </p> <p><strong>Ejemplo</strong>:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                <code class="language-python" data-prismjs-copy="Copy">
                  # Filtrar los números impares de la lista usando lambda y filter
                  numbers = [1, 2, 3, 4, 5, 6, 7]
                  result = filter(lambda x: x % 2 != 0, numbers)
                  print(list(result))  # [1, 3, 5, 7]
                </code>
              </pre> <p> En este caso, <code>lambda x: x % 2 != 0</code> es la función que devuelve <code>True</code> solo para los números impares, filtrando así esos números de la lista. </p> </div>   </div> </article>   <article class="pt-5 row" id="comment"> <br> <h2>COMENTARIOS</h2> <p> Si tiene alguna inquietud, duda o ha encontrado algún error, por favor infórmelo a través del formulario disponible para este propósito. </p> <div class="d-flex justify-content-center"> <form action="https://formsubmit.co/herreraforeroeduardo@gmail.com" method="post" id="myForm"> <div class="d-flex flex-column input-group justify-content-center"> <label for="name" class="pe-2">Nombre:</label> <input type="text" name="name" id="name" placeholder="Eduardo Herrera Forero" class="rounded" required> <label for="email" class="pe-2">Email:</label> <input type="email" name="email" id="email" placeholder="herreraforeroeduardo@gmail.com" class="rounded" required> <label for="message" class="pe-2">Mensaje:</label> <textarea name="message" id="message" cols="30" rows="5" placeholder="Su comentario..." class="rounded rounded-3"></textarea> <input class="border border-2 btn btn-outline-light my-3 rounded-pill" type="submit" value="Enviar..."> </div> <p> La política de privacidad, y los términos y condiciones están disponibles en el formulario de contacto. </p> </form> </div> </article>  </section> </main>   <aside class="col-lg-3 d-lg-block d-none pt-5"> <h2 class="h3">En Este Artículo</h2> <ul class="list-group"> <li class="list-group-item"> <a href="#iteradores">Iteradores</a> </li> <li class="list-group-item"> <a href="#generadores">Generadores</a> </li> <li class="list-group-item"> <a href="#cierres">Cierres</a> </li> <li class="list-group-item"> <a href="#laFuncionLambda">La Función lambda</a> </li> </ul> </aside>  </div>   <button onclick="topFunction()" id="myBtnScroll" title="Go to top"> <svg width="32" height="32" fill="currentColor" class="bi bi-arrow-bar-up" style="margin-left:-2px" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 10a.5.5 0 0 0 .5-.5V3.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 3.707V9.5a.5.5 0 0 0 .5.5m-7 2.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5"/></svg> </button>  </body></html>