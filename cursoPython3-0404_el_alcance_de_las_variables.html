<!DOCTYPE html><html lang="es" data-bs-theme="dark"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Aprende todo sobre el alcance de variables en Python: locales, globales y nonlocal. Ejemplos prácticos de scope, buenas prácticas y consejos para evitar errores comunes en tus programas."><meta name="title" content="Alcance de las Variables Python 3 - Ing. Eduardo Herrera Forero."><meta name="author" content="Ing. Eduardo Herrera Forero"><meta name="application-name" content="EHF"><meta name="robots" content="index, follow"><link rel="canonical" href="https://eduardoherreraf.github.io/cursoPython3-0404_el_alcance_de_las_variables.html"><meta property="og:type" content="website"><meta property="og:title" content="Alcance de las Variables Python 3 - Ing. Eduardo Herrera Forero."><meta property="og:description" content="Aprende todo sobre el alcance de variables en Python: locales, globales y nonlocal. Ejemplos prácticos de scope, buenas prácticas y consejos para evitar errores comunes en tus programas."><meta property="og:image" content="https://i.imgur.com/JKbKYrO.png"><meta property="og:image:alt" content="Logo del ingeniero Eduardo Herrera Forero"><meta property="og:url" content="https://eduardoherreraf.github.io/cursoPython3-0404_el_alcance_de_las_variables.html"><meta property="og:locale" content="es_CO"><meta name="twitter:card" content="content" ="summary"><meta name="twitter:title" content="Alcance de las Variables Python 3 - Ing. Eduardo Herrera Forero."><meta name="twitter:description" content="Aprende todo sobre el alcance de variables en Python: locales, globales y nonlocal. Ejemplos prácticos de scope, buenas prácticas y consejos para evitar errores comunes en tus programas."><meta name="twitter:image" content="https://i.imgur.com/JKbKYrO.png"><meta name="twitter:image:alt" content="Logo del ingeniero Eduardo Herrera Forero"><meta name="twitter:url" content="https://eduardoherreraf.github.io/cursoPython3-0404_el_alcance_de_las_variables.html"><meta name="twitter:site" content="@ehfeduardo"><link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.d2cbc014.png"><link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.02c0440e.png"><link rel="icon" type="image/png" sizes="192x192" href="android-chrome-192x192.9d63268f.png"><link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.a17b4569.png"><link rel="manifest" href="site.webmanifest"><link rel="class" ="navbar-brand d-flex align-items-center ms-2 text-decoration-none"="navbar-brand d-flex align-items-center ms-2 text-decoration-none" href="safari-pinned-tab.cd218f89.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><title>Alcance de las Variables Python 3 - Ing. Eduardo Herrera Forero.</title><link rel="stylesheet" href="index.f4f410ce.css"><script type="module" defer src="index.d07dbcde.js"></script><meta name="google-site-verification" content="2H5ZMCD1_xl7oxaiqnopfdQBnIXVIOfmW0UBSa5sQJc"></head><body>  <nav class="border border-1 fixed-top nav-underline navbar navbar-expand-lg"> <div class="container-fluid">  <a class="align-items-center d-flex ms-2 navbar-brand text-decoration-none" href="index.html"> <img src="logo.f31ffce0.png" alt="Logo de Ing. Eduardo Herrera Forero" width="30" height="30" class="align-text-top d-inline-block me-1"> <span class="d-lg-inline d-none">Ing. Eduardo Herrera Forero</span> </a>  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button>  <div class="collapse ms-auto navbar-collapse text-center" id="navbarSupportedContent"> <ul class="justify-content-lg-end mb-2 mb-lg-0 ms-auto navbar-nav w-100"> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html">SOBRE MÍ</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#resume">EXPERIENCIA</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#portfolio">PORTAFOLIO</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#studies">ESTUDIOS</a> </li> <li class="nav-item"> <a class="active mx-1 nav-link text-decoration-none" href="index.html#blog">PUBLICACIONES</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#contact">CONTACTO</a> </li> </ul> </div> </div> </nav>   <div class="col mx-1 row"> <main class="col-lg-9 pt-5"> <section class="pb-3">  <article class="border-1 border-bottom pb-3 row" data-bs-spy="scroll" data-bs-target="#list-example" data-bs-smooth-scroll="true"> <div> <header> <h1>El Alcance de las Variables en Python</h1> </header> <p> El alcance de las variables en Python es un concepto fundamental que determina la visibilidad y la duración de las variables en un programa. Comprender cómo funcionan las variables y su alcance es crucial para evitar errores y escribir código más eficiente y legible. Este artículo explora los diferentes tipos de alcance de las variables en Python, incluyendo el alcance local, global y no local, así como ejemplos prácticos que ilustran cada uno de estos conceptos. </p> <div class="imagen text-center"> <figure> <img src="https://i.ibb.co/1RVDMWw/alcance.jpg" class="img-fluid rounded-4" width="50%" alt="El Alcance de las Variables en Python  " title="Comprendiendo el alcance de las variables en Python"> <figcaption>El Alcance de las Variables en Python</figcaption> </figure> </div>  <div id="alcanceLocal" class="mt-5"> <h2 class="mt-1">Alcance Local</h2> <p> El alcance local es un concepto fundamental en Python y otros lenguajes de programación. Se refiere al contexto específico en el que una variable está definida y accesible dentro de un programa. En Python, el alcance local se relaciona principalmente con las funciones y los bloques de código que contienen variables propias que no son visibles fuera de ese contexto. </p>  <div> <h3>¿Qué es el Alcance Local?</h3> <p> Cuando se declara una variable dentro de una función, su alcance se limita a esa función. Esto significa que: </p> <ul> <li>Solo puede ser utilizada dentro de la función.</li> <li>No puede ser accedida desde fuera de la función.</li> <li>Una vez que la función termina de ejecutarse, la variable se destruye.</li> </ul> <p>Ejemplo:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    def mi_funcion():
                        variable_local = "Hola desde dentro de la función"
                        print(variable_local)
                    mi_funcion()  # Imprime "Hola desde dentro de la función"
                    print(variable_local)  # Esto causaría un error, ya que variable_local solo existe dentro de mi_funcion(
                  </code>
                </pre> </div>   <div> <h3>¿Por Qué Es Importante el Alcance Local?</h3> <ul> <li> <span class="fw-bold">Evita conflictos</span>: Al limitar el alcance de las variables, se reduce la posibilidad de que dos variables con el mismo nombre se confundan en diferentes partes del código. </li> <li> <span class="fw-bold">Organización del código</span>: Ayuda a mantener el código más organizado y fácil de entender, ya que las variables están definidas donde se utilizan. </li> <li> <span class="fw-bold">Modularidad</span>: Permite crear funciones más independientes y reutilizables. </li> </ul> </div>   <div> <h3>¿Cómo Funciona el Alcance en Python?</h3> <p>Python sigue la regla LEGB para determinar el alcance de una variable:</p> <ul> <li><span class="fw-bold">Local</span>: Dentro de la función actual.</li> <li><span class="fw-bold">Enclosing</span>: Dentro de una función anidada.</li> <li> <span class="fw-bold">Global</span>: En el módulo actual, fuera de todas las funciones. </li> <li> <span class="fw-bold">Built-in</span>: En el módulo builtins, que contiene funciones y nombres integrados como <code>print()</code> o <code>len()</code>. </li> </ul> <p>Ejemplo de alcance anidado:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    def funcion_externa():
                        variable_externa = "Soy externa"
                        def funcion_interna():
                            variable_interna = "Soy interna"
                            print(variable_externa)  # Se puede acceder a variable_externa
                            print(variable_interna)
                        funcion_interna()
                    funcion_externa()       # Salida: Soy externa Soy interna
                  </code>
                </pre> </div>   <div> <h3>Recomendaciones</h3> <ul> <li>Utilizar nombres descriptivos para las variables.</li> <li>Evitar usar variables globales a menos que sea estrictamente necesario.</li> <li>Aprovechar el alcance local para crear funciones más modulares y reutilizables.</li> </ul> </div>   <div> <h3>Diferencias entre Alcance Local y Global</h3> <p> El alcance local contrasta directamente con el alcance global, donde las variables están definidas fuera de cualquier función y son accesibles desde cualquier parte del programa. </p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    x = 10  # Variable de alcance global
                    def sumar(numero):
                        y = numero + x  # x es accesible porque tiene alcance global
                        return y
                    print(sumar(5))  # Salida: 15
                    print(x)  # Salida: 10
                    print(y)  # Error: NameError: name 'y' is not defined
                  </code>
                </pre> <p> El comando <code>print(y)</code> genera un error porque la variable <code>y</code> tiene un alcance local y únicamente es accesible dentro de la función <code>sumar()</code>. </p> </div>  </div>   <div id="palabraReservadaGlobal" class="mt-5"> <h2 class="mt-1">Palabra Reservada Global</h2> <p> En Python, una variable global es aquella que se define fuera de cualquier función o clase y, por lo tanto, es accesible desde cualquier parte del código. Esto significa que su valor puede ser modificado o consultado desde cualquier función o módulo. </p>  <div> <h3>La palabra clave "global"</h3> <p> Para indicar que una variable dentro de una función se refiere a una variable global existente, se utiliza la palabra clave <code>global</code> seguida del nombre de la variable. Esto le indica al intérprete de Python que no debe crear una nueva variable local con el mismo nombre, sino que debe utilizar la variable global. </p> </div>   <div> <h3>¿Cuándo usar "global"?</h3> <ul> <li> <span class="fw-bold">Modificar variables globales dentro de funciones</span>: Si se necesita cambiar el valor de una variable global desde una función, se debe declarar como global dentro de esa función. </li> <li> <span class="fw-bold">Acceso a variables globales desde dentro de funciones</span>: Si simplemente se quiere leer el valor de una variable global dentro de una función, no es estrictamente necesario declararla como global. Sin embargo, declararla de esta manera puede mejorar la legibilidad del código. </li> </ul> <p>Ejemplo:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    # Definición de una variable global
                    contador = 0
                    def incrementar_contador():
                        global contador
                        contador += 1
                        print(f"Contador incrementado: {contador}")
                    # Llamada a la función
                    incrementar_contador()  # Salida: Contador incrementado: 1
                    incrementar_contador()  # Salida: Contador incrementado: 2
                  </code>
                </pre> </div>   <div> <h3>Consideraciones Importantes:</h3> <ul> <li> <span class="fw-bold">Uso moderado</span>: El uso excesivo de variables globales puede dificultar la depuración y el mantenimiento del código, ya que los cambios en una variable global pueden afectar a muchas partes del programa. </li> <li> <span class="fw-bold">Alternativas</span>: En muchos casos, es preferible pasar variables como argumentos a las funciones o utilizar variables locales dentro de las funciones. Esto hace que el código sea más modular y fácil de entender. </li> <li> <span class="fw-bold">Alcance de las variables</span>: Es importante comprender el concepto de alcance (scope) en Python para utilizar correctamente las variables globales y locales. </li> <li> <span class="fw-bold">Evita conflictos de nombres</span>: Cada variable local tiene su propio espacio de nombres, lo que reduce la posibilidad de que se sobrescriban accidentalmente. </li> <li> <span class="fw-bold">Mejora la legibilidad</span>: Al limitar el alcance de las variables, se hace más fácil seguir el flujo de datos en un programa. </li> <li> <span class="fw-bold">Fomenta la modularidad</span>: Las funciones con variables locales son más independientes y fáciles de reutilizar. </li> </ul> </div>  </div>   <div id="alcanceGlobal" class="mt-5"> <h2 class="mt-1">Alcance Global</h2>  <div> <h3>Variables Globales: Visibles en Todo el Programa</h3> <p> El alcance global se refiere a las variables que se definen en el nivel más alto de un script o módulo, fuera de cualquier función o clase. Estas variables son accesibles desde cualquier parte del código, lo que las hace útiles para almacenar información que debe ser compartida entre múltiples funciones o clases. </p> <p> A continuación, se presenta un ejemplo sencillo para ilustrar el uso del alcance global en Python: </p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    # Definición de una variable global
                    contador = 0
                    def incrementar_contador():
                        global contador
                        contador += 1
                        print(f"Contador incrementado: {contador}")
                    # Llamada a la función
                    incrementar_contador()  # Salida: Contador incrementado: 1
                    incrementar_contador()  # Salida: Contador incrementado: 2
                  </code>
                </pre> <p> En este ejemplo, la variable <code>contador</code> se define en el ámbito global. Dentro de la función <code>incrementar_contador</code>, se utiliza la palabra clave <code>global</code> para indicar que se está refiriendo a la variable global <code>contador</code>. Esto permite que la función modifique el valor de contador cada vez que se llama. </p> </div>  <div> <h3>Buenas Prácticas</h3> <ul> <li> <span class="fw-bold">Minimizar el uso de variables globales</span>: Trata de utilizar variables locales siempre que sea posible. </li> <li> <span class="fw-bold">Utilizar argumentos y valores de retorno</span>: Pasa datos a las funciones a través de argumentos y devuelve resultados a través de valores de retorno. </li> <li> <span class="fw-bold">Considerar el uso de clases</span>: Las clases encapsulan datos y métodos, lo que puede ayudar a organizar el código y evitar conflictos de nombres. </li> </ul> </div>   </div>   <div id="alcanceNoLocal" class="mt-5"> <h2 class="mt-1">Alcance No Local</h2>  <div> <h3>Alcance No Local en Python: Más Allá de lo Local</h3> <p> En el mundo de la programación en Python, la comprensión del alcance de las variables es fundamental para escribir código limpio, eficiente y libre de errores. El alcance determina dónde se puede acceder a una variable dentro de un programa. Generalmente, las variables tienen un alcance local, lo que significa que solo son accesibles dentro de la función o bloque de código en el que se definen. Sin embargo, existen situaciones en las que necesitamos acceder o modificar variables que se encuentran fuera de nuestro alcance local inmediato. Aquí es donde entra en juego el concepto de alcance no local. </p> </div>   <div> <h3>¿Qué es el Alcance No Local?</h3> <p> El alcance no local se refiere a la capacidad de una función de acceder a variables definidas en un ámbito superior, como en una función envolvente. Esto es especialmente útil cuando necesitamos modificar el valor de una variable que ya existe en un contexto más amplio, sin tener que pasarla como argumento a la función. </p> </div>   <div> <h3>La Palabra Clave nonlocal</h3> <p> Para declarar que se quiere modificar una variable no local dentro de una función, utilizamos la palabra clave <code>nonlocal</code>. Esta palabra le indica al intérprete de Python que la variable a la que estamos haciendo referencia no es una nueva variable local, sino una variable que ya existe en un ámbito superior. </p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    def outer_function():
                        x = "valor externo"
                        def inner_function():
                            nonlocal x
                            x = "nuevo valor"
                            print(x)
                    inner_function()
                    print(x)
                    outer_function()
                  </code>
                </pre> <p>Código explicado:</p> <ul> <li> <span class="fw-bold"><code>def outer_function()</code></span>: Define una función llamada <code>outer_function()</code>. </li> <li> <span class="fw-bold"><code>x = "valor externo"</code></span>: Dentro de <code>outer_function()</code>, se crea una variable local x con el valor <code>valor externo</code>. </li> <li> <span class="fw-bold"><code>def inner_function()</code></span>: Define una función anidada llamada <code>inner_function</code>. </li> <li> <span class="fw-bold"><code>nonlocal x</code></span>: Declara que x no es una variable local de <code>inner_function</code>, sino que se refiere a la variable x de la función contenedora (<code>outer_function()</code>). </li> <li> <span class="fw-bold"><code>x = "nuevo valor"</code></span>: Modifica el valor de x en el ámbito de <code>outer_function()</code> a <code>nuevo valor</code>. </li> <li> <span class="fw-bold"><code>print(x)</code></span>: Imprime el valor actual de x, que ahora es <code>nuevo valor</code>. </li> <li> <span class="fw-bold"><code>inner_function()</code></span>: Llama a <code>inner_function()</code>, lo que provoca que: <ul> <li>Se cambie el valor de <code>x</code> a <code>nuevo valor</code>.</li> <li>Se imprima <code>nuevo valor</code>.</li> </ul> </li> <li> <span class="fw-bold"><code>print(x)</code></span>: Imprime el valor actual de x después de la ejecución de <code>inner_function</code>, que sigue siendo <code>nuevo valor</code>. </li> <li> <span class="fw-bold"><code>outer_function()</code></span>: Llama a <code>outer_function()</code>, iniciando todo el proceso. </li> </ul> <p>Salida del programa:</p> <ul> <li> El primer print dentro de <code>inner_function</code> imprime: <code>nuevo valor</code> </li> <li> El segundo print dentro de <code>outer_function</code> imprime el mismo valor: <code>nuevo valor</code> </li> </ul> </div>   <div> <h3>Usos Comunes del Alcance No Local</h3> <ul> <li> <span class="fw-bold">Closures</span>: Los closures son funciones que "recuerdan" las variables de su entorno léxico, incluso después de que la función que las creó haya terminado de ejecutarse. El alcance no local es fundamental para crear closures. </li> <li> <span class="fw-bold">Modificación de variables en bucles</span>: En algunos casos, es necesario modificar una variable externa desde dentro de un bucle anidado. </li> <li> <span class="fw-bold">Creación de contadores y acumuladores</span>: El alcance no local permite crear contadores o acumuladores que se actualizan a medida que se ejecuta una función. </li> </ul> </div>   <div> <h3>Precauciones al Usar Alcance No Local</h3> <ul> <li> <span class="fw-bold">Exceso de acoplamiento</span>: El uso excesivo de variables no locales puede hacer que el código sea más difícil de entender y mantener, ya que las dependencias entre diferentes partes del programa se vuelven menos claras. </li> <li> <span class="fw-bold">Efectos secundarios no deseados</span>: Modificar variables no locales puede tener efectos secundarios inesperados en otras partes del programa. </li> <li> <span class="fw-bold">Alternativas</span>: En muchos casos, es preferible utilizar argumentos y valores de retorno para pasar datos entre funciones, en lugar de depender del alcance no local. </li> </ul> </div>  </div>   <div id="laRecursividad" class="mt-5"> <h2 class="mt-1">La Recursividad en Python: Un Concepto Autoreferencial</h2> <p> La recursividad es un concepto fundamental en programación que implica que una función se llame a sí misma. En Python, esta técnica permite resolver problemas complejos dividiéndolos en subproblemas más pequeños y similares, hasta llegar a un caso base que se resuelve directamente </p>  <div> <h3>¿Cómo funciona la Recursividad?</h3> <p>Una función recursiva se compone de dos partes esenciales:</p> <ul> <li> <span class="fw-bold">Caso base</span>: Es la condición que detiene la recursión. Cuando se alcanza el caso base, la función devuelve un valor y deja de llamarse a sí misma. </li> <li> <span class="fw-bold">Caso recursivo</span>: Es la parte de la función donde se llama a sí misma con un conjunto de argumentos modificados, acercándose así al caso base. </li> </ul> <p>Ejemplo:</p> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    def factorial(n):
                        if n == 0:
                            return 1  # Caso base
                        else:
                            return n * factorial(n-1)  # Caso recursivo
                  </code>
                </pre> <p> En este ejemplo, el factorial de un número se define en términos del factorial de un número menor. La función se llama a sí misma repetidamente hasta que n llega a 0, que es el caso base. </p> </div>   <div> <h3>Ventajas de la Recursividad</h3> <ul> <li> <span class="fw-bold">Legibilidad</span>: En muchos casos, las soluciones recursivas pueden ser más concisas y fáciles de entender que las iterativas. </li> <li> <span class="fw-bold">Estructura de datos</span>: La recursividad es ideal para trabajar con estructuras de datos recursivas como árboles y listas enlazadas. </li> <li> <span class="fw-bold">Dividir y conquistar</span>: Permite descomponer problemas complejos en subproblemas más manejables. </li> </ul> </div>   <div> <h3>Desventajas de la Recursividad</h3> <ul> <li> <span class="fw-bold">Consumo de memoria</span>: Cada llamada recursiva consume memoria en la pila. Si la recursión es demasiado profunda, puede provocar un desbordamiento de pila. </li> <li> <span class="fw-bold">Dificultad de depuración</span>: Los errores en funciones recursivas pueden ser más difíciles de identificar y depurar. </li> <li> <span class="fw-bold">Ineficiencia</span>: En algunos casos, las soluciones iterativas pueden ser más eficientes en términos de tiempo de ejecución. </li> </ul> </div>   <div> <h3>Casos de Uso Comunes</h3> <ul> <li>Cálculo de factoriales, números de Fibonacci, etc.</li> <li> <span class="fw-bold">Ordenamiento de datos</span>: Algoritmos como el quicksort utilizan la recursividad de forma efectiva. </li> <li> <span class="fw-bold">Búsqueda en estructuras de datos</span>: La búsqueda en árboles binarios es un ejemplo clásico de recursividad. </li> <li> <span class="fw-bold">Procesamiento de lenguajes</span>: Los compiladores y analizadores sintácticos emplean técnicas recursivas para analizar la estructura de los programas. </li> </ul> </div>   <div> <h3>Consideraciones Importantes</h3> <ul> <li> <span class="fw-bold">Caso base</span>: Es fundamental definir un caso base claro para evitar bucles infinitos. </li> <li> <span class="fw-bold">Optimización</span>: En algunos casos, es posible optimizar funciones recursivas utilizando técnicas como la memoización para evitar recalcular los mismos valores. </li> <li> <span class="fw-bold">Alternativas</span>: No siempre la recursividad es la mejor opción. En ocasiones, las soluciones iterativas pueden ser más eficientes o más fáciles de entender. </li> </ul> </div>  </div>  </div> </article>   <article class="pt-5 row" id="comment"> <br> <h2>COMENTARIOS</h2> <p> Si tiene alguna inquietud, duda o ha encontrado algún error, por favor infórmelo a través del formulario disponible para este propósito. </p> <div class="d-flex justify-content-center"> <form action="https://formspree.io/f/mdkdawkg" method="post" id="myForm"> <div class="d-flex flex-column input-group justify-content-center"> <label for="name" class="pe-2">Nombre:</label> <input type="text" name="name" id="name" placeholder="User" class="rounded" required> <label for="email" class="pe-2">Email:</label> <input type="email" name="email" id="email" placeholder="user@mail.com" class="rounded" required> <label for="message" class="pe-2">Mensaje:</label> <textarea name="message" id="message" cols="30" rows="5" placeholder="Su comentario..." class="rounded rounded-3"></textarea> <input class="border border-2 btn btn-outline-light my-3 rounded-pill" type="submit" value="Enviar..."> </div> <p> La política de privacidad, y los términos y condiciones están disponibles en el formulario de contacto. </p> </form> </div> </article>  </section> </main>   <aside class="col-lg-3 d-lg-block d-none pt-5"> <h2 class="h3">En Este Artículo</h2> <ul class="list-group"> <li class="list-group-item"> <a href="#alcanceLocal">Alcance Local</a> </li> <li class="list-group-item"> <a href="#palabraReservadaGlobal">Palabra Reservada Global</a> </li> <li class="list-group-item"> <a href="#alcanceGlobal">Alcance Global</a> </li> <li class="list-group-item"> <a href="#alcanceNoLocal">Alcance No Local</a> </li> <li class="list-group-item"> <a href="#laRecursividad">La Recursividad</a> </li> </ul> </aside>  </div>   <button onclick="topFunction()" id="myBtnScroll" title="Go to top"> <svg width="32" height="32" fill="currentColor" class="bi bi-arrow-bar-up" style="margin-left:-2px" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 10a.5.5 0 0 0 .5-.5V3.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 3.707V9.5a.5.5 0 0 0 .5.5m-7 2.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5"/></svg> </button>  </body></html>