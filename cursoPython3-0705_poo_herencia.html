<!DOCTYPE html><html lang=es data-bs-theme=dark><link rel=stylesheet href=EduardoHerreraForero.f3ce418f.css><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1"><meta name=description content="Se profundizará en el concepto de herencia, explorando la construcción de jerarquías de clases y analizando los criterios que definen una implementación coherente y significativa de este principio de programación orientada a objetos."><meta name=title content="POO: Herencia Python 3 - Ing. Eduardo Herrera Forero."><meta name=author content="Ing. Eduardo Herrera Forero"><meta name=application-name content=EHF><meta name=robots content="index, follow"><link rel=canonical href=https://eduardoherreraf.github.io/cursoPython3-0705_poo_herencia.html><meta property=og:type content=website><meta property=og:title content="POO: Herencia Python 3 - Ing. Eduardo Herrera Forero."><meta property=og:description content="Se profundizará en el concepto de herencia, explorando la construcción de jerarquías de clases y analizando los criterios que definen una implementación coherente y significativa de este principio de programación orientada a objetos."><meta property=og:image content=https://i.imgur.com/JKbKYrO.png><meta property=og:image:alt content="Logo del ingeniero Eduardo Herrera Forero"><meta property=og:url content=https://eduardoherreraf.github.io/cursoPython3-0705_poo_herencia.html><meta property=og:locale content=es_CO><meta name=twitter:card content=summary><meta name=twitter:title content="POO: Herencia Python 3 - Ing. Eduardo Herrera Forero."><meta name=twitter:description content="Se profundizará en el concepto de herencia, explorando la construcción de jerarquías de clases y analizando los criterios que definen una implementación coherente y significativa de este principio de programación orientada a objetos."><meta name=twitter:image content=https://i.imgur.com/JKbKYrO.png><meta name=twitter:image:alt content="Logo del ingeniero Eduardo Herrera Forero"><meta name=twitter:url content=https://eduardoherreraf.github.io/cursoPython3-0705_poo_herencia.html><meta name=twitter:site content=@ehfeduardo><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.96046c77.png><link rel=icon type=image/png sizes=32x32 href=favicon-32x32.f7991d03.png><link rel=icon type=image/png sizes=192x192 href=android-chrome-192x192.4500461c.png><link rel=icon type=image/png sizes=16x16 href=favicon-16x16.060ee0ac.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=safari-pinned-tab.df3b9c22.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>POO: Herencia Python 3 - Ing. Eduardo Herrera Forero.</title><script type=module src=EduardoHerreraForero.b1453780.js></script><meta name=google-site-verification content=2H5ZMCD1_xl7oxaiqnopfdQBnIXVIOfmW0UBSa5sQJc><body>
  
  <nav class="border border-1 fixed-top nav-underline navbar navbar-expand-lg">
    <div class=container-fluid>
      
      <a class="align-items-center d-flex ms-2 navbar-brand" href=index.html>
        <img src=logo.08948a42.png alt="Logo de Ing. Eduardo Herrera Forero" width=30 height=30 class="align-text-top d-inline-block me-1">
        <span class="d-lg-inline d-none">Ing. Eduardo Herrera Forero</span>
      </a>
      
      <button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
        <span class=navbar-toggler-icon></span>
      </button>
      
      <div class="collapse ms-auto navbar-collapse text-center" id=navbarSupportedContent>
        <ul class="justify-content-lg-end mb-2 mb-lg-0 ms-auto navbar-nav w-100">
          <li class=nav-item>
            <a class="mx-1 nav-link" href=index.html>SOBRE MÍ</a>
          </li>
          <li class=nav-item>
            <a class="mx-1 nav-link" href=index.html#resume>EXPERIENCIA</a>
          </li>
          <li class=nav-item>
            <a class="mx-1 nav-link" href=index.html#portfolio>PORTAFOLIO</a>
          </li>
          <li class=nav-item>
            <a class="mx-1 nav-link" href=index.html#studies>ESTUDIOS</a>
          </li>
          <li class=nav-item>
            <a class="mx-1 nav-link publicaciones-activo" href=index.html#blog>PUBLICACIONES</a>
          </li>
          <li class=nav-item>
            <a class="mx-1 nav-link" href=index.html#contact>CONTACTO</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  

  
  <div class=container-fluid id=introduccion>
    <main class=row>
      <section class="col-lg-9 pb-3 pt-5 px-lg-4">
        
        <article class="border-1 border-bottom pb-3 row" data-bs-spy=scroll data-bs-target=#list-example data-bs-smooth-scroll=true>
          <div>
            <header>
              <h1>POO: Herencia en Python</h1>
            </header>

            
            <div class=mt-5>
              <h2>Introducción</h2>
              <p>
                La Programación Orientada a Objetos (POO) es un paradigma
                fundamental en el desarrollo de software que permite organizar
                el código de manera más eficiente y modular. Uno de los
                conceptos clave de la POO es la herencia, que permite a las
                clases heredar atributos y métodos de otras clases. En este
                documento, exploraremos los fundamentos de la herencia en
                Python, sus beneficios, y cómo implementarla en nuestros
                programas.
              </p>
              <p>
                La Programación Orientada a Objetos (POO) es un paradigma de
                programación que organiza el código en torno a objetos, los
                cuales combinan datos (atributos) y funciones (métodos). Uno
                de los pilares fundamentales de la POO es la herencia, que
                permite crear nuevas clases basadas en clases existentes.
              </p>
              <div class="centrar-imagen imagen50">
                <figure>
                  <img src=https://i.ibb.co/BLLRnCg/pooherencia.jpg class=img-fluid alt="POO: Herencia en Python  " title="Entendiendo la Herencia en Python">
                  <figcaption>POO: Herencia en Python</figcaption>
                </figure>
              </div>
            </div>
            
            <div id=que-es-la-herencia class=mt-5>
              <h2>¿Qué es la Herencia?</h2>
              <p>
                En Python, la herencia es un mecanismo de la programación
                orientada a objetos (POO) que permite crear nuevas clases
                basadas en clases existentes. La clase existente se denomina
                clase base o superclase, y la nueva clase se denomina clase
                derivada o subclase. La herencia permite que la clase derivada
                herede atributos y métodos de la clase base, lo que facilita
                la reutilización de código y la organización de jerarquías de
                clases.
              </p>
              <p>
                Aquí se tiene un ejemplo básico de cómo funciona la herencia
                en Python:
              </p>
              <div class=ej-sintaxis>
                <pre data-src-status=loaded tabindex=0>                    <code class=language-python data-prismjs-copy=Copy>
                      # Definición de la clase base
                      class Animal:
                          def __init__(self, nombre):
                              self.nombre = nombre
                          def hacer_sonido(self):
                              pass
                      # Definición de la clase derivada
                      class Perro(Animal):
                          def hacer_sonido(self):
                              return "Guau"
                      class Gato(Animal):
                          def hacer_sonido(self):
                              return "Miau"
                      # Creación de instancias de las clases derivadas
                      perro = Perro("Fido")
                      gato = Gato("Whiskers")
                      # Uso de métodos heredados y sobrescritos
                      print(perro.nombre)  # Salida: Fido
                      print(perro.hacer_sonido())  # Salida: Guau
                      print(gato.nombre)  # Salida: Whiskers
                      print(gato.hacer_sonido())  # Salida: Miau
                    </code>
                  </pre>
              </div>
              <p>En este ejemplo:</p>
              <ul>
                <li>
                  <code class=language-python>Animal</code> es la clase base
                  que tiene un método
                  <code class=language-python>hacer_sonido</code> que no
                  hace nada (<code class=language-python>pass</code>).
                </li>
                <li>
                  <code class=language-python>Perro</code> y
                  <code class=language-python>Gato</code> son clases
                  derivadas que heredan de
                  <code class=language-python>Animal</code>.
                </li>
                <li>
                  Ambas clases derivadas sobrescriben el método
                  <code class=language-python>hacer_sonido</code>
                  para proporcionar una implementación específica.
                </li>
              </ul>
              <p>
                La herencia permite que
                <code class=language-python>Perro</code> y
                <code class=language-python>Gato</code> hereden el método
                <code class=language-python>__init__</code> de
                <code class=language-python>Animal</code>, lo que significa
                que pueden inicializar el atributo nombre de la misma manera
                que la clase base. Además, pueden sobrescribir métodos de la
                clase base para proporcionar comportamientos específicos.
              </p>
            </div>
            
            
            <div id=herencia-multiple class=mt-5>
              <h2>Herencia Múltiple</h2>
              <p>
                La herencia múltiple en Python permite que una clase herede de
                más de una clase base. Esto significa que una clase derivada
                puede heredar atributos y métodos de múltiples clases base. La
                herencia múltiple puede ser útil para combinar comportamientos
                de diferentes clases, pero también puede introducir
                complejidad, especialmente en términos de resolución de
                métodos y atributos cuando hay conflictos.
              </p>
              <div class=ej-sintaxis>
                <pre data-src-status=loaded tabindex=0>                    <code class=language-python data-prismjs-copy=Copy>
                      # Definición de la primera clase base
                      class Animal:
                          def __init__(self, nombre):
                              self.nombre = nombre
                          def hacer_sonido(self):
                              pass
                      # Definición de la segunda clase base
                      class Volador:
                          def volar(self):
                              return "Estoy volando"
                      # Definición de la clase derivada que hereda de ambas clases base
                      class Pajaro(Animal, Volador):
                          def hacer_sonido(self):
                              return "Pío"
                      # Creación de una instancia de la clase derivada
                      pajaro = Pajaro("Piolín")
                      # Uso de métodos heredados de ambas clases base
                      print(pajaro.nombre)  # Salida: Piolín
                      print(pajaro.hacer_sonido())  # Salida: Pío
                      print(pajaro.volar())  # Salida: Estoy volando
                    </code>
                  </pre>
              </div>
              <p>En este ejemplo:</p>
              <ul>
                <li>
                  <code class=language-python>Animal</code> es una clase
                  base que tiene un método
                  <code class=language-python>hacer_sonido</code> y un
                  atributo <code class=language-python>nombre</code>.
                </li>
                <li>
                  <code class=language-python>Volador</code> es otra clase
                  base que tiene un método
                  <code class=language-python>volar</code>.
                </li>
                <li>
                  <code class=language-python>Pajaro</code> es una clase
                  derivada que hereda de ambas clases
                  <code class=language-python>base</code>,
                  <code class=language-python>Animal</code> y
                  <code class=language-python>Volador</code>.
                </li>
              </ul>
              
              <div>
                <h3>Consideraciones Sobre la Herencia Múltiple</h3>
                <ul>
                  <li>
                    La herencia única ofrece una estructuración más clara y
                    predecible del código, facilitando su comprensión y
                    mantenimiento.
                  </li>
                  <li>
                    La herencia múltiple introduce complejidad significativa,
                    aumentando el riesgo de errores en la implementación y
                    comprensión de las interacciones entre superclases.
                  </li>
                  <li>
                    En sistemas con herencia múltiple, la resolución de
                    métodos y la sobrescritura pueden volverse notablemente
                    complicadas. El uso de
                    <code class=language-python>super()</code> se torna
                    ambiguo, especialmente en jerarquías de herencia más
                    profundas.
                  </li>
                  <li>
                    La herencia múltiple puede comprometer el principio de
                    responsabilidad única, ya que genera clases que combinan
                    funcionalidades de diferentes fuentes sin una cohesión
                    inherente.
                  </li>
                  <li>
                    Recomendamos considerar la herencia múltiple como un
                    último recurso. En la mayoría de los casos, los patrones
                    de composición y delegación ofrecen soluciones más
                    flexibles, legibles y mantenibles.
                  </li>
                </ul>
              </div>
              
              
              <div>
                <h3>Orden de Resolución de Métodos (MRO)</h3>
                <p>
                  La Orden de Resolución de Métodos (<abbr title="Mean Relative Order">MRO</abbr>) es un concepto
                  fundamental en la programación orientada a
                  objetos, especialmente en lenguajes que soportan herencia
                  múltiple, como Python. La MRO determina el orden en el que
                  se buscan los métodos y atributos en una jerarquía de clases
                  cuando se realiza una llamada a un método o se accede a un
                  atributo.
                </p>
                
                <div>
                  <h4>¿Por qué es Importante la MRO?</h4>
                  <p>
                    En lenguajes que soportan herencia múltiple, una clase
                    puede heredar de múltiples clases base. Esto puede llevar
                    a ambigüedades sobre qué método o atributo debe ser
                    utilizado si múltiples clases base definen el mismo método
                    o atributo. La MRO resuelve estas ambigüedades
                    proporcionando un orden específico en el que se buscan los
                    métodos y atributos.
                  </p>
                </div>
                
                
                <div>
                  <h4>MRO en Python</h4>
                  <p>
                    Python utiliza un algoritmo llamado C3 Linearization para
                    determinar la MRO. Este algoritmo garantiza que las clases
                    sean recorridas en un orden que respeta la jerarquía de
                    herencia y evita conflictos.
                  </p>
                  <p>Ejemplo:</p>
                  <div class=ej-sintaxis>
                    <pre data-src-status=loaded tabindex=0>                        <code class=language-python data-prismjs-copy=Copy>
                          # Clase base A, define un método general llamado "method"
                          class A:
                              def method(self):
                                  print("Method in A")
                          # Clase B hereda de A y sobrescribe el método "method"
                          class B(A):
                              def method(self):
                                  print("Method in B")
                          # Clase C también hereda de A y sobrescribe el método "method"
                          class C(A):
                              def method(self):
                                  print("Method in C")
                          # Clase D hereda de B y C, utilizando herencia múltiple
                          class D(B, C):
                              pass  # No sobrescribe "method", por lo que usa el MRO para resolver qué método ejecutar
                          # Creación de un objeto de la clase D
                          d = D()
                          # Llamada al método "method" del objeto d
                          d.method()
                          # Salida: "Method in B"
                          # Luego imprime: None (porque el método method() no retorna ningún valor, por lo que print() imprime el valor predeterminado de retorno, que es None)
                          # Imprime el MRO (Orden de Resolución de Métodos) de la clase D
                          print(D.__mro__)
                          # Salida: (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)
                          # Esto muestra el orden en el que Python buscará métodos cuando se llamen desde una instancia de D.
                          # Otra forma de obtener el MRO usando el método mro()
                          print(D.mro())
                          # Salida: Igual que el anterior, porque ambos muestran el orden de resolución de métodos.
                        </code>
                      </pre>
                  </div>
                  <p>
                    Cuando se llama a
                    <code class=language-python>d.method()</code>, Python
                    buscará el método
                    <code class=language-python>method</code> en el
                    siguiente orden:
                  </p>
                  <ul>
                    <li>
                      Clase <code class=language-python>D</code>: Hereda de
                      ambas clases <code class=language-python>B</code> y
                      <code class=language-python>C</code>. No sobrescribe
                      el método method.
                    </li>
                    <li>
                      Clase <code class=language-python>B</code>: Hereda de
                      <code class=language-python>A</code> y sobrescribe el
                      método method, que imprime
                      <code class=language-python>"Method in B"</code>.
                    </li>
                    <li>
                      Clase <code class=language-python>C</code>: También
                      hereda de <code class=language-python>A</code> y
                      sobrescribe el método
                      <code class=language-python>method</code>, que imprime
                      <code class=language-python>"Method in C"</code>.
                    </li>
                    <li>
                      Clase <code class=language-python>A</code>: Define el
                      método <code class=language-python>method</code>, que
                      imprime
                      <code class=language-python>"Method in A"</code>.
                    </li>
                    <li>
                      Finalmente, si no lo encuentra en ninguna de las clases
                      anteriores, buscará en
                      <code class=language-python>object</code>.
                    </li>
                  </ul>
                  <p>
                    Como la clase <code class=language-python>D</code> no
                    proporciona su propia implementación del método, Python
                    continúa su búsqueda. Encuentra la implementación en la
                    clase <code class=language-python>B</code>. En
                    consecuencia, cuando se invoca
                    <code class=language-python>method()</code>, se
                    ejecutará la versión de la clase
                    <code class=language-python>B</code>, imprimiendo
                    <code class=language-python>"Method in B"</code> y ahí
                    termina la búsqueda.
                  </p>
                </div>
                
              </div>
              
            </div>
            
            
            <div id=metodos-especiales-y-super class=mt-5>
              <h2>Métodos especiales y super()</h2>
              
              <div>
                <h3>issubclass()</h3>
                <p>
                  La función
                  <code class=language-python>issubclass()</code> en Python
                  es una función integrada que se utiliza para determinar si
                  una clase es una subclase de otra. Esto es útil al trabajar
                  con jerarquías de clases y herencia.
                </p>
                <div class=ej-sintaxis>
                  <pre data-src-status=loaded tabindex=0>                      <code class=language-python data-prismjs-copy=Copy>
                        issubclass(subclass, class)
                        # Salida: True si la subclase es derivada de la clase.
                      </code>
                    </pre>
                </div>
                <p>Ejemplo: Verificar una subclase directa:</p>
                <div class=ej-sintaxis>
                  <pre data-src-status=loaded tabindex=0>                      <code class=language-python data-prismjs-copy=Copy>
                        class A
                            pass
                        class B(A):
                            pass
                        print(issubclass(B, A))  # True
                        print(issubclass(A, B))  # False
                      </code>
                    </pre>
                </div>
                <p>Uso con múltiples clases en una tupla:</p>
                <div class=ej-sintaxis>
                  <pre data-src-status=loaded tabindex=0>                      <code class=language-python data-prismjs-copy=Copy>
                        # Definición de clases
                        class A:
                            pass
                        class B(A):
                            pass
                        class C(B):
                            pass
                        # Verificaciones con issubclass()
                        print(issubclass(B, A))  # True: B es subclase de A
                        print(issubclass(A, B))  # False: A no es subclase de B
                        print(issubclass(C, A))  # True: C hereda indirectamente de A
                        # Uso de issubclass() con una tupla
                        print(issubclass(C, (A, B))) # True: C es subclase de A y también de B
                      </code>
                    </pre>
                </div>
              </div>
              
              
              <div>
                <h3>isinstance()</h3>
                <p>
                  La función
                  <code class=language-python>isinstance()</code> en Python
                  se utiliza para verificar si un objeto pertenece a una clase
                  o a una subclase específica. Es particularmente útil para
                  validar tipos de datos en un programa y mejorar la
                  legibilidad y la seguridad del código.
                </p>
                <div class=ej-sintaxis>
                  <pre data-src-status=loaded tabindex=0>                      <code class=language-python data-prismjs-copy=Copy>
                        isinstance(objectName, ClassName_or_tuple)
                      </code>
                    </pre>
                </div>
                <p>Ejemplo: Verificar múltiples clases con una tupla:</p>
                <div class=ej-sintaxis>
                  <pre data-src-status=loaded tabindex=0>                      <code class=language-python data-prismjs-copy=Copy>
                        class MiClase:
                          pass
                        # Crear una instancia de la clase
                        obj = MiClase()
                        # Verificar si el objeto es una instancia de MiClase
                        print(f"¿Es 'obj' una instancia de MiClase? {isinstance(obj, MiClase)}")  # True
                      </code>
                    </pre>
                </div>
              </div>
              
              
              <div>
                <h3>El Operador is</h3>
                <p>
                  En programación, el operador
                  <code class=language-python>is</code> es un operador en
                  Python que se utiliza para comprobar si dos variables o
                  objetos son el mismo objeto en memoria, es decir, si tienen
                  la misma ubicación de memoria.
                </p>
                <p>Ejemplo:</p>
                <div class=ej-sintaxis>
                  <pre data-src-status=loaded tabindex=0>                      <code class=language-python data-prismjs-copy=Copy>
                        a = [1, 2, 3]
                        b = a
                        c = [1, 2, 3]
                        print(a is b)  # True, porque a y b apuntan al mismo objeto en memoria
                        print(a is c)  # False, porque a y c son dos objetos diferentes con el mismo contenido
                      </code>
                    </pre>
                </div>
                
                <div>
                  <h4>Diferencia Clave</h4>
                  <ul>
                    <li>
                      <code class=language-python>==</code> compara el valor
                      de los objetos.
                    </li>
                    <li>
                      <code class=language-python>is</code> compara si las
                      referencias de los objetos son las mismas (es decir, si
                      ambos apuntan al mismo lugar en memoria).
                    </li>
                  </ul>
                </div>
                
              </div>
              
              
              <div>
                <h3>super()</h3>
                <p>
                  En Python, la función super() es utilizada para llamar a
                  métodos de una clase base (superclase) desde una clase
                  derivada (subclase). Es especialmente útil en el contexto de
                  la herencia, cuando se quiere acceder a los métodos o
                  atributos de una clase padre sin tener que referirse
                  explícitamente a ella.
                </p>
                
                <div>
                  <h4>¿Cómo Funciona super()?</h4>
                  <p>
                    <code class=language-python>super()</code> se usa
                    principalmente en el método
                    <code class=language-python>__init__()</code> para
                    inicializar una clase base, pero también se puede usar
                    para invocar cualquier otro método de la clase base. Su
                    uso facilita la reutilización del código en una jerarquía
                    de clases.
                  </p>
                  <p>Ejemplo:</p>
                  <div class=ej-sintaxis>
                    <pre data-src-status=loaded tabindex=0>                        <code class=language-python data-prismjs-copy=Copy>
                          class Animal:
                              def __init__(self, nombre):
                                  self.nombre = nombre
                              def hablar(self):
                                  print(f'{self.nombre} hace un sonido')
                          class Perro(Animal):
                              def __init__(self, nombre, raza):
                                  super().__init__(nombre)  # Llama al __init__ de la clase base (Animal)
                                  self.raza = raza
                              def hablar(self):
                                  super().hablar()  # Llama al método hablar de la clase base (Animal)
                                  print(f'{self.nombre} ladra')
                          mi_perro = Perro("Rex", "Pastor Alemán")
                          mi_perro.hablar()
                          # salida: Rex hace un sonido
                          # salida: Rex ladra
                        </code>
                      </pre>
                  </div>
                  <p>Explicación:</p>
                  <ul>
                    <li>
                      La clase
                      <code class=language-python>Perro</code> hereda de
                      <code class=language-python>Animal</code>.
                    </li>
                    <li>
                      Se utiliza
                      <code class=language-python>super().__init__(nombre)</code>
                      para llamar al constructor de la clase base
                      <code class=language-python>Animal</code> y asignar el
                      atributo <code class=language-python>nombre</code>.
                    </li>
                    <li>
                      Se usa
                      <code class=language-python>super().hablar()</code>
                      para llamar al método
                      <code class=language-python>hablar()</code> de la
                      clase base antes de agregar funcionalidad adicional en
                      la clase derivada.
                    </li>
                  </ul>
                </div>
                
                
                <div>
                  <h4>¿Cuándo Usar super()?</h4>
                  <ul>
                    <li>
                      <span class=fw-bold>Herencia múltiple</span>: En
                      Python, una clase puede heredar de más de una clase
                      base. <code class=language-python>super()</code> ayuda
                      a manejar la llamada a los métodos de las clases base en
                      el orden correcto.
                    </li>
                    <li>
                      <span class=fw-bold>Métodos de clase</span>: Cuando se
                      necesita modificar o extender el comportamiento de un
                      método de la clase base sin redefinirlo completamente.
                    </li>
                  </ul>
                </div>
                
              </div>
              
            </div>
            
            
            <div id=comoconstruir-una-jerarquia-de-clases class=mt-5>
              <h2>Cómo Construir una Jerarquía de Clases</h2>
              <p>
                Construir una jerarquía de clases en Python implica definir
                varias clases y establecer relaciones de herencia entre ellas.
                Aquí tienes un ejemplo básico para ilustrar cómo hacerlo:
              </p>
              <ul>
                <li>
                  <strong>Definir la clase base</strong>: Esta es la clase
                  principal de la que heredarán otras clases.
                </li>
                <li>
                  <strong>Definir las clases derivadas</strong>: Estas clases
                  heredan de la clase base y pueden extender o modificar su
                  comportamiento.
                </li>
              </ul>
              <p>
                A continuación, se muestra un ejemplo de una jerarquía de
                clases para un sistema de gestión de empleados:
              </p>
              <div class=ej-sintaxis>
                <pre data-src-status=loaded tabindex=0>                    <code class=language-python data-prismjs-copy=Copy>
                      # Clase base
                      class Empleado:
                          def __init__(self, nombre, edad, salario):
                              self.nombre = nombre
                              self.edad = edad
                              self.salario = salario
                          def mostrar_informacion(self):
                              return f"Nombre: {self.nombre}, Edad: {self.edad}, Salario: {self.salario}"
                      # Clase derivada 1
                      class Gerente(Empleado):
                          def __init__(self, nombre, edad, salario, departamento):
                              super().__init__(nombre, edad, salario)
                              self.departamento = departamento
                          def mostrar_informacion(self):
                              return f"{super().mostrar_informacion()}, Departamento: {self.departamento}"
                      # Clase derivada 2
                      class Desarrollador(Empleado):
                          def __init__(self, nombre, edad, salario, lenguaje_programacion):
                              super().__init__(nombre, edad, salario)
                              self.lenguaje_programacion = lenguaje_programacion
                          def mostrar_informacion(self):
                              return f"{super().mostrar_informacion()}, Lenguaje de Programación: {self.lenguaje_programacion}"
                      # Crear instancias de las clases
                      empleado = Empleado("Juan Pérez", 30, 50000)
                      gerente = Gerente("María López", 40, 80000, "Ventas")
                      desarrollador = Desarrollador("Carlos Gómez", 25, 60000, "Python")
                      # Mostrar información de las instancias
                      print(empleado.mostrar_informacion())
                      print(gerente.mostrar_informacion())
                      print(desarrollador.mostrar_informacion())
                      # salida: Nombre: Juan Pérez, Edad: 30, Salario: 50000
                      # salida: Nombre: María López, Edad: 40, Salario: 80000, Departamento: Ventas
                      # salida: Nombre: Carlos Gómez, Edad: 25, Salario: 60000, Lenguaje de Programación: Python
                    </code>
                  </pre>
              </div>
              <p>Explicación</p>
              <ul>
                <li>
                  <strong>Clase Base (Empleado)</strong>:
                  <ul>
                    <li>
                      Tiene un constructor (<code class=language-python>__init__</code>) que inicializa los atributos
                      <code class=language-python>nombre</code>,
                      <code class=language-python>edad</code> y
                      <code class=language-python>salario</code>.
                    </li>
                    <li>
                      Tiene un método
                      <code class=language-python>mostrar_informacion</code>
                      que devuelve una cadena con la información del empleado.
                    </li>
                  </ul>
                </li>
                <li>
                  <strong>Clase Derivada 1 (Gerente)</strong>:
                  <ul>
                    <li>
                      Hereda de <code class=language-python>Empleado</code>.
                    </li>
                    <li>
                      Añade un atributo adicional
                      <code class=language-python>departamento</code>.
                    </li>
                    <li>
                      Sobrescribe el método
                      <code class=language-python>mostrar_informacion</code>
                      para incluir el departamento.
                    </li>
                  </ul>
                </li>
                <li>
                  <strong>Clase Derivada 2 (Desarrollador)</strong>:
                  <ul>
                    <li>
                      Hereda de <code class=language-python>Empleado</code>.
                    </li>
                    <li>
                      Añade un atributo adicional
                      <code class=language-python>lenguaje_programacion</code>.
                    </li>
                    <li>
                      Sobrescribe el método
                      <code class=language-python>mostrar_informacion</code>
                      para incluir el lenguaje de programación.
                    </li>
                  </ul>
                </li>
                <li>
                  <strong>Creación de Instancias</strong>:
                  <ul>
                    <li>
                      Se crean instancias de
                      <code class=language-python>Empleado</code>,
                      <code class=language-python>Gerente</code> y
                      <code class=language-python>Desarrollador</code>.
                    </li>
                    <li>
                      Se muestra la información de cada instancia utilizando
                      el método
                      <code class=language-python>mostrar_informacion</code>.
                    </li>
                  </ul>
                </li>
              </ul>
              <p>
                Este ejemplo muestra cómo puedes construir una jerarquía de
                clases en Python utilizando herencia y cómo puedes extender y
                sobrescribir métodos en las clases derivadas.
              </p>
              <p>
                Este ejemplo muestra cómo se puede construir una jerarquía de
                clases en Python utilizando herencia y cómo se puede extender
                y sobrescribir métodos en las clases derivadas.
              </p>
            </div>
            
            
            <div id=ventajas-de-la-herencia class=mt-5>
              <h2>Ventajas de la Herencia</h2>
              <p>
                La herencia en Python es un mecanismo de programación
                orientada a objetos que permite crear una nueva clase (llamada
                clase derivada o subclase) basada en una clase existente
                (llamada clase base o superclase). Este enfoque tiene varias
                ventajas significativas:
              </p>
              <ul>
                <li>
                  <span class=fw-bold>Reutilización de código</span>:
                  <ul>
                    <li>
                      Se pueden reutilizar los métodos y atributos de una
                      clase base en una subclase, lo que reduce la duplicación
                      de código.
                    </li>
                    <li>
                      Facilita la escritura de código más limpio y modular.
                    </li>
                  </ul>
                </li>
                <li>
                  <span class=fw-bold>Mantenimiento más sencillo</span>: Al
                  centralizar la lógica compartida en la clase base, cualquier
                  cambio necesario solo debe realizarse en un lugar, lo que
                  simplifica el mantenimiento del código.
                </li>
                <li>
                  <span class=fw-bold>Extensibilidad</span>: Las subclases
                  pueden ampliar o modificar la funcionalidad de las clases
                  base sin afectar a las clases existentes. Esto permite que
                  el código sea más flexible y adaptable a nuevas necesidades.
                </li>
                <li>
                  <span class=fw-bold>Polimorfismo</span>: La herencia
                  facilita la implementación de polimorfismo, lo que permite
                  usar un mismo método o atributo con comportamientos
                  específicos para cada subclase. Esto es útil en situaciones
                  en las que diferentes clases comparten una interfaz común.
                </li>
                <li>
                  <span class=fw-bold>Organización jerárquica</span>:
                  Permite organizar las clases en una jerarquía lógica, lo que
                  mejora la comprensión y legibilidad del código. Por ejemplo,
                  una clase base
                  <code class=language-python>Vehículo</code> puede tener
                  subclases como <code class=language-python>Carro</code> y
                  <code class=language-python>Moto</code>.
                </li>
                <li>
                  <span class=fw-bold>Sobrescritura de métodos</span>: Las
                  subclases pueden redefinir métodos de la clase base para
                  ajustarlos a necesidades específicas, lo que facilita la
                  personalización del comportamiento.
                </li>
                <li>
                  <span class=fw-bold>Compatibilidad con múltiples herencias</span>: Python permite la herencia
                  múltiple, lo que significa que
                  una subclase puede derivarse de más de una clase base,
                  combinando las funcionalidades de todas ellas.
                </li>
              </ul>
              <p>
                En el siguiente ejemplo se muestra cómo la herencia permite
                crear subclases con comportamientos específicos (polimorfismo)
                a partir de una clase base.
              </p>
              <div class=ej-sintaxis>
                <pre data-src-status=loaded tabindex=0>                    <code class=language-python data-prismjs-copy=Copy>
                      class Animal:
                          def __init__(self, nombre):
                              self.nombre = nombre
                          def sonido(self):
                              return "El animal hace un sonido"
                      class Perro(Animal):
                          def sonido(self):
                              return "El perro ladra"
                      class Gato(Animal):
                          def sonido(self):
                              return "El gato maúlla"
                      # Uso de las clases
                      animales = [Perro("Firulais"), Gato("Michi")]
                      for animal in animales:
                          print(f"{animal.nombre}: {animal.sonido()}")
                      # Salida: Firulais: El perro ladra
                      # Salida: Michi: El gato maúlla
                    </code>
                  </pre>
              </div>
            </div>
            
            
            <div id=buenas-practicas class=mt-5>
              <h2>Buenas Prácticas</h2>
              <p>
                En la programación orientada a objetos en Python, la herencia
                es una herramienta poderosa para estructurar el código de
                manera eficiente y reutilizable. Sin embargo, para evitar
                problemas como el acoplamiento excesivo o la complejidad
                innecesaria, es importante seguir ciertas buenas prácticas al
                implementar herencia. A continuación, se presentan algunas
                recomendaciones clave:
              </p>
              <ul>
                <li>
                  <span class=fw-bold>Usar la herencia solo cuando sea necesaria</span>:
                  <ul>
                    <li>
                      <span class=fw-bold>Cuándo usarla</span>: Cuando
                      existe una relación lógica del tipo "es un(a)" (e.g., un
                      Perro es un Animal).
                    </li>
                    <li>
                      <span class=fw-bold>Cuándo evitarla</span>: Si la
                      relación es más bien "tiene un(a)" o "usa un(a)" (e.g.,
                      un Coche tiene un Motor), considere la composición en
                      lugar de la herencia.
                    </li>
                  </ul>
                </li>
                <li>
                  <span class=fw-bold>Mantener las clases base simples</span>: Evite clases base excesivamente
                  complejas. Mantenga su
                  funcionalidad lo más genérica posible para que sean
                  reutilizables y fáciles de extender.
                  <div class=ej-sintaxis>
                    <pre data-src-status=loaded tabindex=0>                        <code class=language-python data-prismjs-copy=Copy>
                          class Persona:
                          def __init__(self, nombre, edad):
                              self.nombre = nombre
                              self.edad = edad
                          def saludar(self):
                              return f"Hola, mi nombre es {self.nombre} y tengo {self.edad} años."
                          # Uso de la clase base
                          persona1 = Persona("Ana", 30)
                          print(persona1.saludar())
                        </code>
                      </pre>
                  </div>
                </li>
                <li>
                  <span class=fw-bold>Evitar herencia múltiple si es posible</span>:
                  <ul>
                    <li>
                      La herencia múltiple puede introducir ambigüedades y
                      problemas de resolución de métodos. Use interfaces o
                      clases mixin para agregar funcionalidades específicas.
                    </li>
                    <li>
                      Ejemplo de una clase mixin:
                      <div class=ej-sintaxis>
                        <pre data-src-status=loaded tabindex=0>                            <code class=language-python data-prismjs-copy=Copy>
                              # Definimos un mixin para agregar la funcionalidad de volar.
                              # Un mixin es una clase que proporciona funcionalidad adicional
                              a otras clases sin ser una clase principal.
                              class VoladorMixin:
                                  def volar(self):
                                      # Este método imprime un mensaje indicando que el objeto puede volar.
                                      print("\u00a1Estoy volando!")
                              # Creamos una clase base llamada "Animal" para representar características generales de los animales.
                              class Animal:
                                  def __init__(self, nombre):
                                      # Cada animal tendrá un nombre.
                                      self.nombre = nombre
                                  def describir(self):
                                      # Este método imprime una descripción básica del animal.
                                      print(f"Soy un animal llamado {self.nombre}.")
                              # Definimos una clase "Ave" que hereda de "Animal" y del mixin "VoladorMixin".
                              # Esto permite que "Ave" combine características generales de los animales
                              # con la capacidad de volar proporcionada por el mixin.
                              class Ave(Animal, VoladorMixin):
                                  def hacer_sonido(self):
                                      # Este método imprime un sonido típico de un ave.
                                      print("P\u00edo")
                              # Ejemplo de uso
                              # Creamos un objeto de la clase "Ave".
                              mi_ave = Ave("Canario")
                              # Llamamos a los métodos de la clase "Ave".
                              mi_ave.describir()   # Imprime: Soy un animal llamado Canario.
                              mi_ave.hacer_sonido()  # Imprime: Pío
                              mi_ave.volar()         # Imprime: ¡Estoy volando!
                            </code>
                          </pre>
                      </div>
                    </li>
                  </ul>
                </li>
                <li>
                  <span class=fw-bold>Usar <code class=language-python>super()</code> para
                    llamar al constructor de la clase base</span>: Siempre que se sobrescriba el método
                  <code class=language-python>__init__</code>, utilice
                  <code class=language-python>super()</code> para garantizar
                  que la clase base sea inicializada correctamente.
                  <div class=ej-sintaxis>
                    <pre data-src-status=loaded tabindex=0>                        <code class=language-python data-prismjs-copy=Copy>
                          class Mamifero(Animal):
                              def __init__(self, nombre, tiene_pelo=True):
                                  super().__init__(nombre)
                                  self.tiene_pelo = tiene_pelo
                        </code>
                      </pre>
                  </div>
                </li>
                <li>
                  <span class=fw-bold>Sobrescribir métodos de manera explícita</span>: Si sobrescribe se un método,
                  estar seguro de que sea
                  claro y documentar su propósito. Llamar a los métodos de la
                  clase base si es necesario.
                  <ul>
                    <li>
                      Para sobrescribir métodos de manera explícita y hacer el
                      código más entendible, se puede utilizar el decorador
                      <code class=language-python>@override</code>,
                      disponible desde Python 3.12. Esto deja claro que el
                      método sobrescribe uno de la clase base. Además, es útil
                      agregar comentarios y dar nombres más descriptivos si es
                      necesario
                    </li>
                    <li>
                      Aquí está el código ejemplo:
                      <div class=ej-sintaxis>
                        <pre data-src-status=loaded tabindex=0>                            <code class=language-python data-prismjs-copy=Copy>
                              from typing import override  # Disponible desde Python 3.12
                              class Mamifero:
                                  def hacer_sonido(self):
                                      print("Sonido genérico de mamífero")
                              class Gato(Mamifero):
                                  @override
                                  def hacer_sonido(self):
                                      # Sobrescribiendo el método 'hacer_sonido' de la clase base
                                      print("Miau")
                              # Ejemplo de uso
                              if __name__ == "__main__":
                                  gato = Gato()
                                  gato.hacer_sonido()  # Salida: Miau
                            </code>
                          </pre>
                      </div>
                    </li>
                  </ul>
                </li>
                <li>
                  <span class=fw-bold>Evitar dependencias circulares</span>:
                  Las dependencias circulares (cuando una clase depende de
                  otra que a su vez depende de la primera) pueden causar
                  problemas difíciles de depurar. Refactorice para evitar
                  estos casos.
                </li>
                <li>
                  <span class=fw-bold>Documentar la jerarquía de clases</span>:
                  <ul>
                    <li>
                      Mantenga una buena documentación sobre cómo se
                      relacionan las clases para evitar confusiones al
                      trabajar con herencia compleja.
                    </li>
                    <li>
                      Utilice herramientas como diagramas UML si es necesario.
                    </li>
                  </ul>
                </li>
                <li>
                  <span class=fw-bold>Aplicar el Principio de Sustitución de Liskov</span>: Una subclase debe poder
                  reemplazar a su clase base sin
                  alterar la funcionalidad del programa. Esto asegura que el
                  diseño sea sólido y fácil de mantener.
                </li>
                <li>
                  <span class=fw-bold>Evitar jerarquías de herencia muy profundas</span>: Las jerarquías de herencia
                  profundas pueden ser difíciles
                  de entender y mantener. Prefiera la composición o el uso de
                  mixins si necesita agregar muchas funcionalidades.
                </li>
              </ul>
            </div>
            
          </div>
        </article>
        
        
        <article class=row id=comments>
          <h2>COMENTARIOS</h2>
          <p>
            Si tiene alguna inquietud, duda o ha encontrado algún error, por
            favor infórmelo a través del formulario disponible para este
            propósito.
          </p>
          <div class="d-flex justify-content-center">
            <form action=https://formspree.io/f/mdkdawkg method=post id=myForm>
              <fieldset class="d-flex flex-column gap-3">
                <legend class="fs-4 text-center">Deje su comentario</legend>

                <div class="d-flex flex-column">
                  <label for=name>Nombre:</label>
                  <input name=name id=name placeholder=User class="form-control rounded" required>
                </div>

                <div class="d-flex flex-column">
                  <label for=email>Email:</label>
                  <input type=email name=email id=email placeholder=user@mail.com class="form-control rounded" required>
                </div>

                <div class="d-flex flex-column">
                  <label for=message>Mensaje:</label>
                  <textarea name=message id=message cols=30 rows=5 placeholder="Su comentario..." class="form-control rounded-3" required></textarea>
                </div>

                <button class="border border-2 btn btn-outline-light my-3 rounded-pill">
                  Enviar
                </button>
              </fieldset>

              <p class="small text-center">
                La política de privacidad, y los términos y condiciones están
                disponibles en el formulario de contacto.
              </p>
            </form>
          </div>
        </article>
        
      </section>
      

      
      <aside class="col-lg-3 d-lg-block d-none">
        <h2>En Este Artículo</h2>
        <div class=menu-scroll>
          <div class=menu-container>
            <div class="border border-1">
              <div class=menu-item><a href=#introduccion class=simple-link>Introducción</a></div>
              <div class=menu-item><a href=#que-es-la-herencia class=simple-link>¿Qué es la Herencia?</a></div>
              <div class=menu-item><a href=#herencia-multiple class=simple-link>Herencia Múltiple</a></div>
              <div class=menu-item><a href=#metodos-especiales-y-super class=simple-link>Métodos especiales y
                  <code class=language-python>super()</code></a></div>
              <div class=menu-item><a href=#comoconstruir-una-jerarquia-de-clases class=simple-link>Cómo Construir
                  una Jerarquía de Clases</a></div>
              <div class=menu-item><a href=#ventajas-de-la-herencia class=simple-link>Ventajas de la Herencia</a>
              </div>
              <div class=menu-item><a href=#buenas-practicas class=simple-link>Buenas Prácticas</a></div>
              
              <div class=menu-item><a href=#comments class=simple-link>Comentarios</a></div>
            </div>
          </div>
        </div>
      </aside>
      
    </main>
    
  </div>
  

  
  <footer class="border-1 border-top m-1 mt-auto row">
    <div class=row>
      
      <address class="align-items-center col-lg-4 d-flex flex-column">
        <div class="fs-2 text-center">Contacto</div>
        <div class="align-items-center d-flex flex-row">
          <i class="bi bi-envelope-at fs-3"></i>
          <span class=ms-3>
            <a class=text-decoration-none href=mailto:ehfeduardo@gmail.com>ehfeduardo@gmail.com</a>
          </span>
        </div>
        <div class="align-items-center d-flex flex-row">
          <i class="bi bi-geo-alt fs-3"></i>
          <span class=ms-3>Bogotá D. C. - Colombia</span>
        </div>
      </address>
      
      <div class="align-items-center col-lg-4 d-flex flex-column h-100 justify-content-center">
        <div>
          <i class="bi bi-c-circle fs-5"></i>
        </div>
        <div class=ms-2>All Rights Reserved 2025</div>
      </div>
      
      <div class="align-items-center col-lg-4 d-flex flex-column">
        <div class="fs-2 text-center">Redes Sociales</div>
        <div class="align-items-center d-flex gap-5 justify-content-evenly">
          <div>
            <a href=https://www.linkedin.com/in/eduardoherreraf/ target=_blank rel="noopener noreferrer">
              <i class="bi bi-linkedin fs-1"></i>
            </a>
          </div>
          <div>
            <a href=https://github.com/eduardoherreraf target=_blank rel="noopener noreferrer">
              <i class="bi bi-github fs-1"></i>
            </a>
          </div>
          <div>
            <a href=https://www.facebook.com/eduardoherreraforero/ target=_blank rel="noopener noreferrer">
              <i class="bi bi-facebook fs-1"></i>
            </a>
          </div>
          <div>
            <a href=https://twitter.com/ehfeduardo/ target=_blank rel="noopener noreferrer">
              <i class="bi bi-twitter-x fs-1"></i>
            </a>
          </div>
        </div>
      </div>
    </div>
    <div class="align-items-center d-flex gap-2 justify-content-center"></div>
  </footer>
  

  
  <button onclick=topFunction() id=myBtnScroll title="Go to top">
    <svg xmlns:xmlns=http://www.w3.org/2000/svg width=32 height=32 fill=currentColor class="bi bi-arrow-bar-up" style=margin-left:-2px viewBox="0 0 16 16"><path fill-rule=evenodd d="M8 10a.5.5 0 0 0 .5-.5V3.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 3.707V9.5a.5.5 0 0 0 .5.5m-7 2.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5"/></svg>
  </button>
  


