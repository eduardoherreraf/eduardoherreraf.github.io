<!DOCTYPE html><html lang="es" data-bs-theme="dark"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Descubre las diferencias clave entre programación procedimental y orientada a objetos en Python. Análisis comparativo de paradigmas con ejemplos prácticos y ventajas."><meta name="tittle" content="Comparando Paradigmas: Programación Procedimental y Orientada a Objetos Python 3 - Ing. Eduardo Herrera Forero."><meta name="author" content="Ing. Eduardo Herrera Forero"><meta name="application-name" content="EHF"><meta name="robots" content="index, follow"><link rel="canonical" href="https://eduardoherreraf.github.io/cursoPython3-0702_comparando_paradigmas_programacion_procedimental_y_orientada_a_objetos.html"><meta property="og:type" content="website"><meta property="og:title" content="Comparando Paradigmas: Programación Procedimental y Orientada a Objetos Python 3 - Ing. Eduardo Herrera Forero."><meta property="og:description" content="Descubre las diferencias clave entre programación procedimental y orientada a objetos en Python. Análisis comparativo de paradigmas con ejemplos prácticos y ventajas."><meta property="og:image" content="https://i.imgur.com/JKbKYrO.png"><meta property="og:image:alt" content="Logo del ingeniero Eduardo Herrera Forero"><meta property="og:url" content="https://eduardoherreraf.github.io/cursoPython3-0702_comparando_paradigmas_programacion_procedimental_y_orientada_a_objetos.html"><meta property="og:locale" content="es_CO"><meta name="twitter:card" content="content" ="summary"><meta name="twitter:title" content="Comparando Paradigmas: Programación Procedimental y Orientada a Objetos Python 3 - Ing. Eduardo Herrera Forero."><meta name="twitter:description" content="Descubre las diferencias clave entre programación procedimental y orientada a objetos en Python. Análisis comparativo de paradigmas con ejemplos prácticos y ventajas."><meta name="twitter:image" content="https://i.imgur.com/JKbKYrO.png"><meta name="twitter:image:alt" content="Logo del ingeniero Eduardo Herrera Forero"><meta name="twitter:url" content="https://eduardoherreraf.github.io/cursoPython3-0702_comparando_paradigmas_programacion_procedimental_y_orientada_a_objetos.html"><meta name="twitter:site" content="@ehfeduardo"><link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.d2cbc014.png"><link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.02c0440e.png"><link rel="icon" type="image/png" sizes="192x192" href="android-chrome-192x192.9d63268f.png"><link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.a17b4569.png"><link rel="manifest" href="site.webmanifest"><link rel="mask-icon" href="safari-pinned-tab.cd218f89.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><title> Comparando Paradigmas: Programación Procedimental y Orientada a Objetos Python 3 - Ing. Eduardo Herrera Forero. </title><link rel="stylesheet" href="index.e1f1769d.css"><script type="module" defer src="index.d07dbcde.js"></script><meta name="google-site-verification" content="2H5ZMCD1_xl7oxaiqnopfdQBnIXVIOfmW0UBSa5sQJc"></head><body>  <nav class="border border-1 fixed-top nav-underline navbar navbar-expand-lg"> <div class="container-fluid">  <a class="align-items-center d-flex ms-2 navbar-brand text-decoration-none" href="index.html"> <img src="logo.f31ffce0.png" alt="Logo de Ing. Eduardo Herrera Forero" width="30" height="30" class="align-text-top d-inline-block me-1"> <span class="d-lg-inline d-none">Ing. Eduardo Herrera Forero</span> </a>  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button>  <div class="collapse ms-auto navbar-collapse text-center" id="navbarSupportedContent"> <ul class="justify-content-lg-end mb-2 mb-lg-0 ms-auto navbar-nav w-100"> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html">SOBRE MÍ</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#resume">EXPERIENCIA</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#portfolio">PORTAFOLIO</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#studies">ESTUDIOS</a> </li> <li class="nav-item"> <a class="active mx-1 nav-link text-decoration-none" href="index.html#blog">PUBLICACIONES</a> </li> <li class="nav-item"> <a class="mx-1 nav-link text-decoration-none" href="index.html#contact">CONTACTO</a> </li> </ul> </div> </div> </nav>   <div class="col mx-1 row"> <main class="col-lg-9 pt-5"> <section class="pb-3">  <article class="border-1 border-bottom pb-3 row" data-bs-spy="scroll" data-bs-target="#list-example" data-bs-smooth-scroll="true"> <div> <header> <h1>Comparando Paradigmas: Programación Procedimental y Orientada a Objetos en Python</h1> </header> <p> Las diferencias y similitudes entre los paradigmas de programación procedimental y orientado a objetos se revelan con claridad mediante un análisis comparativo utilizando Python como lenguaje de referencia. El estudio profundiza en sus características distintivas, explorando las ventajas y desventajas de cada enfoque, mediante ejemplos prácticos que ilustran cómo abordan la resolución de problemas computacionales. </p> <div class="imagen text-center"> <picture> <img src="https://i.ibb.co/xJ6xjwd/procedimentalvspoo.jpg" class="img-fluid rounded-4" width="90%" alt="Comparando Paradigmas: Programación Procedimental y Orientada a Objetos en Python  " title="Eligir el mejor paradigma de programación para el proyecto"> <figcaption> Comparando Paradigmas: Programación Procedimental y Orientada a Objetos en Python </figcaption> </picture> </div>  <div id="QueEsUnaPila" class="mt-5"> <h2 class="mt-1">¿Qué es una Pila?</h2> <p> En programación, una pila es una estructura de datos lineal que sigue el principio LIFO (Last In, First Out), que significa que el último elemento en entrar es el primero en salir. Se utiliza comúnmente para resolver problemas relacionados con el manejo de datos de forma temporal o reversible, como en operaciones de deshacer, análisis de expresiones matemáticas o recorridos de árboles. </p>  <div> <h3>Características Principales de las Pilas</h3> <ul> <li> <span class="fw-bold">LIFO (Last In, First Out)</span>: <ul> <li>El último elemento añadido a la pila será el primero en ser retirado.</li> <li>Similar a una pila de platos: el plato colocado al final se retira primero.</li> </ul> </li> <li> <span class="fw-bold">Operaciones básicas</span>: <ul> <li> <span class="fw-bold">Push</span>: Agrega un elemento a la parte superior de la pila. </li> <li> <span class="fw-bold">Pop</span>: Elimina y retorna el elemento de la parte superior de la pila. </li> <li> <span class="fw-bold">Peek (o Top)</span>: Muestra el elemento superior sin eliminarlo. </li> <li><span class="fw-bold">isEmpty</span>: Verifica si la pila está vacía.</li> <li><span class="fw-bold">Size</span>: Retorna el número de elementos en la pila.</li> </ul> </li> <li> <span class="fw-bold">Implementación</span>: Las pilas pueden ser implementadas usando: <ul> <li> <span class="fw-bold">Arreglos</span>: Usando un índice para señalar la posición superior. </li> <li> <span class="fw-bold">Listas enlazadas</span>: Usando un nodo como el tope de la pila. </li> </ul> </li> <li> <span class="fw-bold">Restricciones</span>: <ul> <li>Solo se puede acceder al elemento en la cima.</li> <li>El acceso es secuencial, no directo como en una lista.</li> </ul> </li> <li> <span class="fw-bold">Ejemplos de uso</span>: <ul> <li> <span class="fw-bold">Recursión</span>: El lenguaje utiliza pilas para manejar las llamadas a funciones. </li> <li> <span class="fw-bold">Deshacer/rehacer</span>: Almacena las acciones del usuario para revertir o repetir cambios. </li> <li> <span class="fw-bold">Evaluación de expresiones matemáticas</span>: Manejo de operadores y operandos. </li> <li> <span class="fw-bold">Recorridos de grafos o árboles</span>: Por ejemplo, en recorridos en profundidad (DFS). </li> </ul> </li> </ul> </div>  </div>   <div id="LaPilaElEnfoqueProcedimental" class="mt-5"> <h2 class="mt-1">La Pila: el Enfoque Procedimental</h2> <p> La pila es una estructura de datos que sigue el principio LIFO (Last In, First Out), es decir, el último elemento en ser insertado será el primero en ser retirado. Este enfoque es útil para resolver problemas que requieren retroceder pasos, como en la navegación por páginas web o en la evaluación de expresiones matemáticas. </p> <p> En este ejemplo, se implementará una pila utilizando listas de Python con un enfoque completamente procedimental. </p>  <div> <h3>Implementación Procedimental de Estructuras de una Pila</h3> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    # Implementación de la pila con enfoque procedimental
                    # Crear una pila vacía
                    def create_stack():
                        return []
                    # Insertar un elemento en la pila
                    def push(stack, element):
                        stack.append(element)
                        print(f"Pushed: {element}")
                    # Eliminar y devolver el elemento superior de la pila
                    def pop(stack):
                        if is_empty(stack):
                            print("Stack is empty! Cannot pop.")
                            return None
                        return stack.pop()
                    # Ver el elemento superior sin eliminarlo
                    def peek(stack):
                        if is_empty(stack):
                            print("Stack is empty! Nothing to peek.")
                            return None
                        return stack[-1]
                    # Verificar si la pila está vacía
                    def is_empty(stack):
                        return len(stack) == 0
                    # Obtener el tamaño de la pila
                    def size(stack):
                        return len(stack)
                    # Ejemplo de uso
                    if __name__ == "__main__":
                        stack = create_stack()
                        push(stack, 10)
                        push(stack, 20)
                        push(stack, 30)
                        print("Top element is:", peek(stack))
                        print("Popped element is:", pop(stack))
                        print("Top element after pop:", peek(stack))
                        print("Stack size:", size(stack))
                        while not is_empty(stack):
                            print("Popped:", pop(stack))
                  </code>
                </pre> </div>   <div> <h3>Explicación de la Implementación Procedimental de una Pila</h3> <ul> <li> <span class="fw-bold"><code>create_stack()</code></span>: Crea y devuelve una lista vacía que representa la pila. </li> <li> <span class="fw-bold"><code>push(stack, element)</code></span>: Este método agrega un nuevo elemento a la pila usando el método append() de listas. Esto se traduce como "empujar" un elemento al tope de la pila. </li> <li> <span class="fw-bold"><code>pop(stack)</code></span>: Retira y devuelve el último elemento agregado a la pila. Verifica si la pila está vacía antes de intentar eliminar un elemento, para evitar errores. Utiliza el método pop() de listas. </li> <li> <span class="fw-bold"><code>peek(stack)</code></span>: Permite ver el elemento que se encuentra en la parte superior de la pila sin removerlo. Esto ayuda a inspeccionar el contenido actual. </li> <li> <span class="fw-bold"><code>is_empty(stack)</code></span>: Verifica si la pila está vacía retornando un valor booleano. Usa la función len() para comprobar si tiene elementos. </li> <li> <span class="fw-bold"><code>size(stack)</code></span>:Devuelve la cantidad de elementos presentes en la pila. Esto es útil para conocer su estado en cualquier momento. </li> <li> <span class="fw-bold">Ejemplo de Uso La sección dentro del bloque if <code>__name__</code> == "<code>__main__</code>"</span>: muestra cómo usar la pila: <ul> <li> Se crean operaciones básicas como agregar elementos (<code>push</code>), eliminar elementos (<code>pop</code>), y verificar el elemento superior (<code>peek</code>). </li> <li> También se ilustra cómo vaciar completamente la pila usando un ciclo <code>while</code>. </li> </ul> </li> </ul> </div>   <div class="mt-5 text-center"> <a href="#" id="myBtnScroll2" title="Go to top"> <svg width="32" height="32" fill="currentColor" class="bi bi-arrow-bar-up" style="margin-left:-2px" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 10a.5.5 0 0 0 .5-.5V3.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 3.707V9.5a.5.5 0 0 0 .5.5m-7 2.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5"/></svg> </a> </div>  </div>   <div id="laPilaElEnfoqueProcedimentalVersusElEnfoqueOrientadoAObjetos" class="mt-5"> <h2 class="mt-1">La Pila: El Enfoque Procedimental Versus El Enfoque Orientado a Objetos</h2>  <div> <h3>Desventajas de Pilas Procedimentales</h3> <p> Las pilas procedimentales, también conocidas como pilas estáticas o simples, tienen algunas desventajas que se deben considerar dependiendo del contexto en el que se utilicen. A continuación se detallan algunas de las principales desventajas de este tipo de estructuras: </p> <ul> <li> <span class="fw-bold">Tamaño fijo</span>: En las pilas procedimentales, el tamaño de la pila suele ser fijo y determinado de antemano. Esto significa que no se puede ajustar dinámicamente según la cantidad de elementos que se necesiten almacenar. Si se alcanza el límite de capacidad, se producirá un desbordamiento de pila. </li> <li> <span class="fw-bold">Eficiencia limitada en memoria</span>: Debido a que se establece un tamaño fijo, se puede desperdiciar memoria si la pila no se llena por completo, o puede desbordarse si se excede la capacidad máxima. Esto resulta ineficiente, ya que no se aprovecha la memoria disponible de manera óptima. </li> <li> <span class="fw-bold">Poca flexibilidad</span>: A diferencia de las pilas dinámicas, que pueden crecer y reducirse según sea necesario, las pilas procedimentales carecen de esta flexibilidad. Esto puede ser un inconveniente cuando se trabaja con datos cuyo tamaño es incierto o variable. </li> <li> <span class="fw-bold">Riesgo de desbordamiento</span>: Dado que el tamaño es fijo, se corre el riesgo de desbordar la pila si se realizan demasiadas operaciones de apilamiento sin haber retirado elementos previamente. Este desbordamiento puede llevar a errores o fallos en el programa. </li> <li> <span class="fw-bold">Acceso limitado</span>: Al ser una estructura de tipo LIFO (Last In, First Out), el acceso a los elementos de la pila está restringido al último elemento insertado. Esto limita la capacidad para realizar operaciones de lectura o modificación de elementos específicos dentro de la pila sin antes desapilar. </li> <li> <span class="fw-bold">Dependencia de la implementación</span>: En muchos casos, las pilas procedimentales dependen de una implementación que podría no ser tan eficiente como las pilas dinámicas, especialmente en lenguajes de programación que no soportan manipulación dinámica de memoria. </li> <li> <span class="fw-bold">Poca reutilización de memoria</span>: Una vez que la pila se llena hasta su capacidad máxima, no se puede reutilizar la memoria hasta que los elementos sean retirados. Esto limita el uso eficiente de la memoria en situaciones de alta carga. </li> </ul> <p> Por lo tanto, aunque las pilas procedimentales pueden ser útiles en situaciones donde el tamaño de los datos es conocido y fijo, presentan desventajas importantes en términos de flexibilidad, eficiencia y manejo de memoria. </p> </div>   <div> <h3>Ventajas de Pilas con Enfoque OOP</h3> <p> El uso de pilas con un enfoque orientado a objetos (OOP, por sus siglas en inglés) ofrece varias ventajas significativas en el desarrollo de software, especialmente cuando se buscan soluciones que sean fáciles de mantener, escalables y reutilizables. A continuación, se detallan algunas de las principales ventajas: </p> <ul> <li> <span class="fw-bold">Encapsulamiento</span>: El enfoque OOP permite encapsular los detalles de implementación de la pila dentro de una clase. Los usuarios solo interactúan con los métodos de la clase (como push(), pop(), peek(), etc.) sin necesidad de preocuparse por la estructura interna o los detalles de memoria, lo que promueve una interfaz clara y sencilla. </li> <li> <span class="fw-bold">Reutilización de código</span>: Al utilizar clases, es posible reutilizar la implementación de la pila en diferentes proyectos o partes del código. Esto mejora la eficiencia en el desarrollo y reduce la redundancia. </li> <li> <span class="fw-bold">Modularidad</span>: Al organizar la pila como una clase dentro de un sistema orientado a objetos, se facilita la separación de responsabilidades. La pila se convierte en un módulo autónomo que puede integrarse con otros módulos sin afectar el funcionamiento global del sistema. </li> <li> <span class="fw-bold">Herencia</span>: En OOP, las pilas pueden ser extendidas mediante la herencia. Por ejemplo, se puede crear una clase derivada que agregue características adicionales a una pila, como pilas con capacidad limitada o con características de monitoreo de desempeño, sin modificar la clase base. Esto facilita la creación de pilas especializadas. </li> <li> <span class="fw-bold">Polimorfismo</span>: El polimorfismo permite que se utilicen diferentes implementaciones de pilas de forma intercambiable. Por ejemplo, se pueden crear pilas con diferentes tipos de almacenamiento (como pilas basadas en listas o en arrays) y usar un enfoque común sin que el código que usa la pila necesite conocer las diferencias entre las implementaciones. </li> <li> <span class="fw-bold">Manejo más sencillo de errores</span>: Con el enfoque OOP, se pueden incluir mecanismos de manejo de excepciones dentro de la clase de la pila. Por ejemplo, si se intenta hacer un pop() en una pila vacía, la clase puede generar una excepción que se puede manejar adecuadamente en el código cliente. </li> <li> <span class="fw-bold">Mejora en la mantenibilidad</span>: El diseño orientado a objetos facilita el mantenimiento y la modificación del código. Si se necesitan cambios en la implementación de la pila (como optimizar el algoritmo o cambiar la estructura de almacenamiento), estos cambios pueden realizarse dentro de la clase sin afectar al resto del código que interactúa con la pila. </li> <li> <span class="fw-bold">Flexibilidad en la estructura interna</span>: Al usar OOP, es posible modificar la estructura interna de la pila sin cambiar la interfaz pública que se expone al usuario. Por ejemplo, la pila podría cambiar de una implementación basada en lista a una basada en una estructura enlazada sin afectar el código que usa la pila. </li> </ul> <p> El uso de pilas con un enfoque OOP permite un código más organizado, modular y fácil de mantener, lo cual es especialmente útil en aplicaciones grandes o en aquellos entornos que requieren una alta flexibilidad y escalabilidad. </p> </div>  </div>   <div id="laPila-ElEnfoqueOrientadoAObjetos" class="mt-5"> <h2 class="mt-1">La Pila: El Enfoque Orientado a Objetos</h2> <p> Las pilas pueden implementarse mediante el enfoque orientado a objetos, aprovechando las características del lenguaje para encapsular el comportamiento y la estructura de la pila. </p>  <div> <h3>Implementación Orientada a Objetos de Estructuras de una Pila</h3> <pre class="line-numbers" data-src-status="loaded" tabindex="0">
                  <code class="language-python" data-prismjs-copy="Copy">
                    class Pila:
                        def __init__(self):
                            """Crea una pila vacía."""
                            self.elementos = []  # Lista para almacenar los elementos
                        def push(self, elemento):
                            """Añade un elemento a la cima de la pila."""
                            self.elementos.append(elemento)  # Añadir elemento al final
                        def pop(self):
                            """Elimina y devuelve el último elemento de la pila."""
                            if not self.is_empty():  # Verificar si la pila no está vacía
                                return self.elementos.pop()  # Eliminar y devolver el último elemento
                            else:
                                return "La pila está vacía"
                        def peek(self):
                            """Devuelve el elemento en la cima sin eliminarlo."""
                            if not self.is_empty():
                                return self.elementos[-1]  # Retorna el último elemento
                            else:
                                return "La pila está vacía"
                        def is_empty(self):
                            """Devuelve True si la pila está vacía, False en caso contrario."""
                            return len(self.elementos) == 0  # Compara el tamaño de la lista
                    # Ejemplo de uso
                    if __name__ == "__main__":
                        # Crear una nueva pila
                        pila = Pila()
                        # Añadir elementos a la pila
                        pila.push(5)
                        pila.push(10)
                        pila.push(15)
                        # Mostrar el elemento en la cima
                        print("Elemento en la cima:", pila.peek())
                        # Eliminar el último elemento
                        print("Elemento eliminado:", pila.pop())
                        # Comprobar si la pila está vacía
                        print("¿La pila está vacía?", pila.is_empty())
                        # Intentar eliminar de una pila vacía
                        pila.pop()
                        pila.pop()
                        print("Elemento eliminado:", pila.pop())
                  </code>
                </pre> </div>   <div> <h3>Explicación de la Implementación Orientada a Objetos de una Pila</h3> <ul> <li> <span class="fw-bold">Atributos y Métodos</span>: <ul> <li> La pila se implementa con una lista (<code>self.elementos</code>) que almacena los datos. </li> <li> <code>push</code>: Usa el método append para agregar un nuevo elemento al final de la lista. </li> <li> <code>pop</code>: Usa el método pop para eliminar y devolver el último elemento. Si la pila está vacía, devuelve un mensaje. </li> <li> <code>peek</code>: Devuelve el último elemento sin eliminarlo. Verifica primero si la pila no está vacía. </li> <li> <code>is_empty</code>: Comprueba si la lista está vacía retornando <code>True</code> o <code>False</code>. </li> </ul> </li> <li> <span class="fw-bold">Ejemplo de Uso</span>: <ul> <li> Se crea una instancia de Pila y se realizan operaciones básicas como agregar, eliminar y consultar elementos. </li> <li> También incluye una verificación para evitar errores al intentar eliminar elementos de una pila vacía. </li> </ul> </li> </ul> </div>  </div>  </div> </article>   <article class="pt-5 row" id="comment"> <br> <h2>COMENTARIOS</h2> <p> Si tiene alguna inquietud, duda o ha encontrado algún error, por favor infórmelo a través del formulario disponible para este propósito. </p> <div class="d-flex justify-content-center"> <form action="https://formsubmit.co/herreraforeroeduardo@gmail.com" method="post" id="myForm"> <div class="d-flex flex-column input-group justify-content-center"> <label for="name" class="pe-2">Nombre:</label> <input type="text" name="name" id="name" placeholder="Eduardo Herrera Forero" class="rounded" required> <label for="email" class="pe-2">Email:</label> <input type="email" name="email" id="email" placeholder="herreraforeroeduardo@gmail.com" class="rounded" required> <label for="message" class="pe-2">Mensaje:</label> <textarea name="message" id="message" cols="30" rows="5" placeholder="Su comentario..." class="rounded rounded-3"></textarea> <input class="border border-2 btn btn-outline-light my-3 rounded-pill" type="submit" value="Enviar..."> </div> <p> La política de privacidad, y los términos y condiciones están disponibles en el formulario de contacto. </p> </form> </div> </article>  </section> </main>   <aside class="col-lg-3 d-lg-block d-none pt-5"> <h2 class="h3">En Este Artículo</h2> <ul class="list-group"> <li class="list-group-item"> <a href="#QueEsUnaPila">¿Qué es una Pila?</a> </li> <li class="list-group-item"> <a href="#LaPilaElEnfoqueProcedimental">La Pila: el Enfoque Procedimental</a> </li> <li class="list-group-item"> <a href="#laPilaElEnfoqueProcedimentalVersusElEnfoqueOrientadoAObjetos">La Pila: El Enfoque Procedimental Versus El Enfoque Orientado a Objetos</a> </li> <li class="list-group-item"> <a href="#laPila-ElEnfoqueOrientadoAObjetos">La Pila: El Enfoque Orientado a Objetos</a> </li> </ul> </aside>  </div>   <button onclick="topFunction()" id="myBtnScroll" title="Go to top"> <svg width="32" height="32" fill="currentColor" class="bi bi-arrow-bar-up" style="margin-left:-2px" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 10a.5.5 0 0 0 .5-.5V3.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 3.707V9.5a.5.5 0 0 0 .5.5m-7 2.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5"/></svg> </button>  </body></html>